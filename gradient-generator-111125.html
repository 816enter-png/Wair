<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Gradient Generator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #000;
        }
        
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            touch-action: none; /* Prevent default touch behaviors */
        }
        
        .mode-switcher {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
        
        .mode-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
        }
        
        .mode-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.6);
        }
        
        .mode-btn.active {
            background: rgba(255, 255, 255, 0.2);
            border-color: white;
        }
        
        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            bottom: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            min-width: 250px;
            max-height: calc(100vh - 40px);
            overflow: hidden;
            z-index: 1000;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
        }
        
        .control-group {
            margin-bottom: 10px;
            flex-shrink: 0;
        }
        
        .distortion-styles {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .animation-directions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .distortion-btn {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.2s ease;
        }
        
        .direction-btn {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.2s ease;
        }
        
        .distortion-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .distortion-btn.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: white;
            font-weight: bold;
        }
        
        .direction-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .direction-btn.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: white;
            font-weight: bold;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        input[type="color"] {
            display: none; /* Hide default color inputs */
        }
        
        .color-swatches {
            margin-bottom: 12px;
            position: relative;
            flex-shrink: 0;
        }
        
        .background-color-section {
            margin-bottom: 12px;
            position: relative;
            flex-shrink: 0;
        }
        
        .color-picker-popup {
            position: fixed;
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 20px;
            display: none;
            z-index: 1001;
            backdrop-filter: blur(10px);
            min-width: 240px;
            max-width: 280px;
            box-sizing: border-box;
        }
        
        .color-picker-popup.show {
            display: block !important;
        }
        
        .color-picker-popup input[type="color"] {
            display: none !important;
        }
        
        .color-gradient-selector {
            position: relative;
            width: 100%;
            height: 150px;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: crosshair;
            background: linear-gradient(to bottom, 
                rgba(255,255,255,1) 0%, 
                rgba(255,255,255,0) 50%, 
                rgba(0,0,0,0) 50%, 
                rgba(0,0,0,1) 100%),
            linear-gradient(to right, #ff0000 0%, #ff0000 100%);
        }
        
        .color-selector-circle {
            position: absolute;
            width: 16px;
            height: 16px;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        
        .hue-slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .hue-preview {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .hue-slider {
            flex: 1;
            height: 20px;
            border-radius: 10px;
            background: linear-gradient(to right, 
                #ff0000 0%, 
                #ffff00 16.66%, 
                #00ff00 33.33%, 
                #00ffff 50%, 
                #0000ff 66.66%, 
                #ff00ff 83.33%, 
                #ff0000 100%);
            cursor: pointer;
            position: relative;
        }
        
        .hue-slider-handle {
            position: absolute;
            width: 24px;
            height: 24px;
            background: white;
            border: 2px solid rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
        }
        
        .hue-slider-handle:active {
            cursor: grabbing;
        }
        
        .color-inputs-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .hex-input-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .rgb-inputs {
            display: flex;
            gap: 8px;
        }
        
        .rgb-input-group {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .rgb-label {
            color: #888;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .rgb-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            color: white;
            padding: 6px 4px;
            font-size: 12px;
            text-align: center;
        }
        
        .rgb-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.15);
        }
        
        .hex-label {
            color: #888;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .hex-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            color: white;
            padding: 6px 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
            text-transform: uppercase;
        }
        
        .hex-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.15);
        }

        
        .color-swatches-label {
            display: block;
            margin-bottom: 15px;
            font-size: 14px;
            text-transform: lowercase;
            letter-spacing: 0px;
        }
        
        .color-circles {
            display: flex;
            gap: 15px;
            align-items: flex-end;
        }
        
        .color-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        
        .delete-btn {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background: transparent;
            border: 2px solid rgba(255, 255, 255, 0.6);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: white;
            transition: all 0.2s ease;
            font-weight: bold;
        }
        
        .delete-btn:hover {
            background: rgba(255, 0, 0, 0.3);
            border-color: rgba(255, 0, 0, 0.8);
            transform: scale(1.05);
        }
        
        .color-circle {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid rgba(255, 255, 255, 0.3);
            transition: all 0.2s ease;
            position: relative;
        }
        
        .color-circle:hover {
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, 0.8);
        }
        
        .color-circle.active {
            border-color: white;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }
        
        .add-color-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: transparent;
            border: 3px solid rgba(255, 255, 255, 0.6);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            color: white;
            transition: all 0.2s ease;
            font-weight: 300;
        }
        
        .add-color-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: white;
            transform: scale(1.05);
        }
        
        .add-color-btn.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .add-color-btn.disabled:hover {
            transform: none;
            background: transparent;
        }
        
        input[type="file"] {
            width: 100%;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            color: white;
            font-size: 12px;
            cursor: pointer;
        }
        
        .value-display {
            font-size: 11px;
            color: #aaa;
            margin-top: 3px;
        }
        
        #status {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 5px;
            color: #0f0;
            font-size: 12px;
        }
        
        .shape-btn:hover {
            background: rgba(255, 255, 255, 0.15) !important;
            transform: scale(1.02);
        }
        
        .shape-btn.active {
            background: rgba(255, 255, 255, 0.25) !important;
            border-color: white !important;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }
        
        .interaction-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 10px;
            color: white;
            font-size: 13px;
            display: none;
            align-items: center;
            gap: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: opacity 0.3s ease;
        }
        
        .interaction-hint.show {
            display: flex;
        }
        
        .cube-icon {
            width: 30px;
            height: 30px;
            position: relative;
            transform-style: preserve-3d;
            animation: rotateCube 3s infinite linear;
        }
        
        .cube-face {
            position: absolute;
            width: 30px;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.6);
        }
        
        .cube-front  { transform: translateZ(15px); }
        .cube-back   { transform: translateZ(-15px) rotateY(180deg); }
        .cube-right  { transform: rotateY(90deg) translateZ(15px); }
        .cube-left   { transform: rotateY(-90deg) translateZ(15px); }
        .cube-top    { transform: rotateX(90deg) translateZ(15px); }
        .cube-bottom { transform: rotateX(-90deg) translateZ(15px); }
        
        @keyframes rotateCube {
            0% { transform: rotateX(0deg) rotateY(0deg); }
            100% { transform: rotateX(360deg) rotateY(360deg); }
        }

        /* FLUID mode specific controls */
        #fluidControls {
            display: none;
        }
    </style>
</head>
<body>
    <div class="mode-switcher">
        <button class="mode-btn active" id="mode3d">3D</button>
        <button class="mode-btn" id="modeFull">FULL</button>
        <button class="mode-btn" id="modeNeat">SMOOTH</button>
        <button class="mode-btn" id="modeFluid">FLUID</button>
        <button class="mode-btn" id="modeMogi">MOGI</button>
    </div>
    
    <canvas id="canvas"></canvas>
    
    <div id="status">Loading...</div>
    
    <div class="interaction-hint" id="interactionHint">
        <div class="cube-icon">
            <div class="cube-face cube-front"></div>
            <div class="cube-face cube-back"></div>
            <div class="cube-face cube-right"></div>
            <div class="cube-face cube-left"></div>
            <div class="cube-face cube-top"></div>
            <div class="cube-face cube-bottom"></div>
        </div>
        <span>Click and drag to interact</span>
    </div>
    
    <div class="controls">
        <h3 style="margin-top: 0;">Editor</h3>
        
        <div class="color-swatches">
            <label class="color-swatches-label">colors</label>
            <div class="color-circles" id="colorCircles">
                <div class="color-item">
                    <button class="delete-btn" data-index="0">−</button>
                    <div class="color-circle" data-index="0" style="background-color: #ff0080;"></div>
                </div>
                <div class="color-item">
                    <button class="delete-btn" data-index="1">−</button>
                    <div class="color-circle" data-index="1" style="background-color: #0080ff;"></div>
                </div>
                <div class="color-item">
                    <button class="delete-btn" data-index="2">−</button>
                    <div class="color-circle" data-index="2" style="background-color: #00ff80;"></div>
                </div>
                <div class="add-color-btn" id="addColorBtn">+</div>
            </div>
            <!-- Color picker popup -->
            <div class="color-picker-popup" id="colorPickerPopup">
                <input type="color" id="colorPicker">
                <div class="color-gradient-selector" id="colorGradientSelector">
                    <div class="color-selector-circle" id="colorSelectorCircle"></div>
                </div>
                <div class="hue-slider-container">
                    <div class="hue-preview" id="huePreview"></div>
                    <div class="hue-slider" id="hueSlider">
                        <div class="hue-slider-handle" id="hueSliderHandle"></div>
                    </div>
                </div>
                <div class="color-inputs-container">
                    <div class="rgb-inputs">
                        <div class="rgb-input-group">
                            <span class="rgb-label">R</span>
                            <input type="number" class="rgb-input" id="rInput" min="0" max="255">
                        </div>
                        <div class="rgb-input-group">
                            <span class="rgb-label">G</span>
                            <input type="number" class="rgb-input" id="gInput" min="0" max="255">
                        </div>
                        <div class="rgb-input-group">
                            <span class="rgb-label">B</span>
                            <input type="number" class="rgb-input" id="bInput" min="0" max="255">
                        </div>
                    </div>
                    <div class="hex-input-container">
                        <span class="hex-label">HEX</span>
                        <input type="text" class="hex-input" id="hexInput" maxlength="7" placeholder="#000000">
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Mood Presets Section -->
        <div class="control-group">
            <label>Mood Presets</label>
            <div class="preset-grid" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 10px;">
                <button class="preset-btn mood-btn" data-mood="happy" style="background: linear-gradient(135deg, #FFD700, #FF69B4, #00CED1); border: 2px solid rgba(255, 255, 255, 0.3); padding: 10px; border-radius: 8px; color: white; cursor: pointer; font-size: 11px; text-transform: uppercase; font-weight: 600; transition: all 0.2s ease;">Happy</button>
                <button class="preset-btn mood-btn" data-mood="chill" style="background: linear-gradient(135deg, #4A90E2, #7B68EE, #48D1CC); border: 2px solid rgba(255, 255, 255, 0.3); padding: 10px; border-radius: 8px; color: white; cursor: pointer; font-size: 11px; text-transform: uppercase; font-weight: 600; transition: all 0.2s ease;">Chill</button>
                <button class="preset-btn mood-btn" data-mood="rage" style="background: linear-gradient(135deg, #FF0000, #FF4500, #8B0000); border: 2px solid rgba(255, 255, 255, 0.3); padding: 10px; border-radius: 8px; color: white; cursor: pointer; font-size: 11px; text-transform: uppercase; font-weight: 600; transition: all 0.2s ease;">Rage</button>
                <button class="preset-btn mood-btn" data-mood="energetic" style="background: linear-gradient(135deg, #FF1493, #00FF00, #FFD700); border: 2px solid rgba(255, 255, 255, 0.3); padding: 10px; border-radius: 8px; color: white; cursor: pointer; font-size: 11px; text-transform: uppercase; font-weight: 600; transition: all 0.2s ease;">Energy</button>
            </div>
        </div>
        
        <div class="background-color-section" id="backgroundSection">
            <label class="color-swatches-label">background</label>
            <div class="color-circles">
                <div class="color-item">
                    <div class="color-circle" id="bgColorCircle" style="background-color: #000000;"></div>
                </div>
            </div>
            <!-- Background color picker popup -->
            <div class="color-picker-popup" id="bgColorPickerPopup">
                <input type="color" id="bgColorPicker">
                <div class="color-gradient-selector" id="bgColorGradientSelector">
                    <div class="color-selector-circle" id="bgColorSelectorCircle"></div>
                </div>
                <div class="hue-slider-container">
                    <div class="hue-preview" id="bgHuePreview"></div>
                    <div class="hue-slider" id="bgHueSlider">
                        <div class="hue-slider-handle" id="bgHueSliderHandle"></div>
                    </div>
                </div>
                <div class="color-inputs-container">
                    <div class="rgb-inputs">
                        <div class="rgb-input-group">
                            <span class="rgb-label">R</span>
                            <input type="number" class="rgb-input" id="bgRInput" min="0" max="255">
                        </div>
                        <div class="rgb-input-group">
                            <span class="rgb-label">G</span>
                            <input type="number" class="rgb-input" id="bgGInput" min="0" max="255">
                        </div>
                        <div class="rgb-input-group">
                            <span class="rgb-label">B</span>
                            <input type="number" class="rgb-input" id="bgBInput" min="0" max="255">
                        </div>
                    </div>
                    <div class="hex-input-container">
                        <span class="hex-label">HEX</span>
                        <input type="text" class="hex-input" id="bgHexInput" maxlength="7" placeholder="#000000">
                    </div>
                </div>
            </div>
        </div>
        
        <div class="control-group">
            <label>Animation Speed</label>
            <input type="range" id="speed" min="0" max="3" step="0.1" value="0.5">
            <div class="value-display" id="speedValue">0.5</div>
        </div>
        
        <!-- 3D Mode Controls - visible by default since 3D is default mode -->
        <div id="3dControls">
            <div class="control-group">
                <label>3D Shape</label>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 15px;">
                    <button class="shape-btn active" data-shape="sphere" style="padding: 8px; background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 6px; color: white; cursor: pointer; font-size: 11px; text-transform: uppercase; font-weight: 600; transition: all 0.2s ease;">Sphere</button>
                    <button class="shape-btn" data-shape="torus" style="padding: 8px; background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 6px; color: white; cursor: pointer; font-size: 11px; text-transform: uppercase; font-weight: 600; transition: all 0.2s ease;">Torus</button>
                </div>
            </div>
            <div class="control-group">
                <label>Color Blend</label>
                <input type="range" id="colorBlend" min="0.1" max="5" step="0.1" value="1">
                <div class="value-display" id="colorBlendValue">1.0</div>
            </div>
        </div>
        
        <!-- SMOOTH Mode Controls - only visible in SMOOTH mode -->
        <div id="smoothControls" style="display: none;">
            <div class="control-group">
                <label>Wave Amplitude</label>
                <input type="range" id="waveAmplitude" min="1" max="10" step="0.5" value="5">
                <div class="value-display" id="waveAmplitudeValue">5.0</div>
            </div>
        </div>
        
        <!-- FLUID Mode Controls - only visible in FLUID mode -->
        <div id="fluidControls" style="display: none;">
            <div class="control-group">
                <label>Wave Direction</label>
                <select id="waveDirection" style="width: 100%; padding: 8px; background: rgba(255,255,255,0.9); border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; color: black; font-size: 12px;">
                    <option value="horizontal" style="color: black;">Horizontal</option>
                    <option value="vertical" style="color: black;">Vertical</option>
                    <option value="diagonal" style="color: black;">Diagonal</option>
                </select>
            </div>
            
            <!-- Advanced Settings Toggle -->
            <div class="control-group" style="margin-top: 15px;">
                <button id="advancedToggle" style="width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; color: white; cursor: pointer; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; transition: all 0.2s ease;">
                    ▶ Advanced Settings
                </button>
            </div>
            
            <!-- Advanced Settings Section (Hidden by default) -->
            <div id="advancedSettings" style="display: none; margin-top: 10px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 5px;">
                <div class="control-group">
                    <label>Wave Frequency X</label>
                    <input type="range" id="waveFreqX" min="1" max="10" step="0.5" value="4">
                    <div class="value-display" id="waveFreqXValue">4.0</div>
                </div>
                
                <div class="control-group">
                    <label>Wave Frequency Y</label>
                    <input type="range" id="waveFreqY" min="1" max="10" step="0.5" value="4">
                    <div class="value-display" id="waveFreqYValue">4.0</div>
                </div>
                
                <div class="control-group">
                    <label>Horizontal Pressure</label>
                    <input type="range" id="horizontalPressure" min="0" max="10" step="0.5" value="5">
                    <div class="value-display" id="horizontalPressureValue">5.0</div>
                </div>
                
                <div class="control-group">
                    <label>Vertical Pressure</label>
                    <input type="range" id="verticalPressure" min="0" max="10" step="0.5" value="5">
                    <div class="value-display" id="verticalPressureValue">5.0</div>
                </div>
            </div>
        </div>
        
        <!-- MOGI Mode Controls -->
        <div id="mogiControls" style="display: none;">
            <div class="control-group">
                <label>Head</label>
                <div style="display: flex; align-items: center; gap: 10px; margin-top: 10px;">
                    <div id="headColorPreview" style="width: 40px; height: 40px; border-radius: 50%; background: #FFD93D; border: 2px solid rgba(255,255,255,0.3); cursor: pointer;"></div>
                    <div style="flex: 1;">
                        <label style="font-size: 10px; margin-bottom: 5px;">Size</label>
                        <input type="range" id="headSize" min="1" max="3" step="0.1" value="2">
                    </div>
                    <div class="value-display" id="headSizeValue">2.0</div>
                </div>
            </div>
            
            <div class="control-group">
                <label>Left Eye</label>
                <select id="leftEyeShape" style="width: 100%; padding: 6px; background: rgba(255,255,255,0.9); border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; color: black; font-size: 11px; margin-bottom: 10px;">
                    <option value="curved-up" style="color: black;">Curved Up (^^)</option>
                    <option value="curved-down" style="color: black;">Curved Down</option>
                    <option value="flat" style="color: black;">Flat (—)</option>
                    <option value="circle" style="color: black;" selected>Circle</option>
                </select>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <div id="leftEyeColorPreview" style="width: 30px; height: 30px; border-radius: 50%; background: #000000; border: 2px solid rgba(255,255,255,0.3); cursor: pointer;"></div>
                    <div style="flex: 1;">
                        <input type="range" id="leftEyeSize" min="0.1" max="0.5" step="0.02" value="0.2">
                    </div>
                    <div class="value-display" id="leftEyeSizeValue">0.20</div>
                </div>
            </div>
            
            <div class="control-group">
                <label>Right Eye</label>
                <select id="rightEyeShape" style="width: 100%; padding: 6px; background: rgba(255,255,255,0.9); border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; color: black; font-size: 11px; margin-bottom: 10px;">
                    <option value="curved-up" style="color: black;">Curved Up (^^)</option>
                    <option value="curved-down" style="color: black;">Curved Down</option>
                    <option value="flat" style="color: black;">Flat (—)</option>
                    <option value="circle" style="color: black;" selected>Circle</option>
                </select>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <div id="rightEyeColorPreview" style="width: 30px; height: 30px; border-radius: 50%; background: #000000; border: 2px solid rgba(255,255,255,0.3); cursor: pointer;"></div>
                    <div style="flex: 1;">
                        <input type="range" id="rightEyeSize" min="0.1" max="0.5" step="0.02" value="0.2">
                    </div>
                    <div class="value-display" id="rightEyeSizeValue">0.20</div>
                </div>
            </div>
            
            <div class="control-group">
                <label>Mouth</label>
                <select id="mouthShape" style="width: 100%; padding: 6px; background: rgba(255,255,255,0.9); border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; color: black; font-size: 11px; margin-bottom: 10px;">
                    <option value="curved-up" style="color: black;" selected>Smile (⌣)</option>
                    <option value="curved-down" style="color: black;">Frown (⌒)</option>
                    <option value="flat" style="color: black;">Flat (—)</option>
                    <option value="circle" style="color: black;">Circle</option>
                </select>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <div id="mouthColorPreview" style="width: 30px; height: 30px; border-radius: 50%; background: #FF0000; border: 2px solid rgba(255,255,255,0.3); cursor: pointer;"></div>
                    <div style="flex: 1;">
                        <input type="range" id="mouthSize" min="0.1" max="0.8" step="0.02" value="0.3">
                    </div>
                    <div class="value-display" id="mouthSizeValue">0.30</div>
                </div>
            </div>
        </div>
        
        <div class="control-group">
            <label>Size</label>
            <input type="range" id="size" min="0.5" max="2.5" step="0.1" value="1.5">
            <div class="value-display" id="sizeValue">1.5</div>
        </div>
        
        <div class="control-group">
            <label id="noiseScaleLabel">Noise Scale</label>
            <input type="range" id="noiseScale" min="0.5" max="5" step="0.1" value="2">
            <div class="value-display" id="noiseScaleValue">2.0</div>
        </div>
        
        <div class="control-group">
            <label>Animation Direction</label>
            <div class="animation-directions">
                <button class="direction-btn active" data-direction="radial">Radial</button>
                <button class="direction-btn" data-direction="horizontal">Horizontal</button>
                <button class="direction-btn" data-direction="vertical">Vertical</button>
                <button class="direction-btn" data-direction="diagonal">Diagonal</button>
                <button class="direction-btn" data-direction="spiral">Spiral</button>
            </div>
        </div>
        
        <div class="control-group">
            <label>Distortion Style</label>
            <div class="distortion-styles" id="normalDistortionStyles">
                <button class="distortion-btn active" data-style="smooth">Smooth</button>
                <button class="distortion-btn" data-style="waves">Waves</button>
                <button class="distortion-btn" data-style="liquid">Liquid</button>
                <button class="distortion-btn" data-style="turbulent">Turbulent</button>
                <button class="distortion-btn" data-style="minimal">Minimal</button>
            </div>
            <div class="distortion-styles" id="torusDistortionStyles" style="display: none;">
                <button class="distortion-btn active" data-style="smooth">Smooth</button>
                <button class="distortion-btn" data-style="liquid">Liquid</button>
                <button class="distortion-btn" data-style="turbulent">Turbulent</button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
        
        const status = document.getElementById('status');
        status.textContent = 'Three.js loaded!';
        
        // Configuration
        const config = {
            colors: ['#ff0080', '#0080ff', '#00ff80'],
            backgroundColor: '#000000',
            speed: 0.5,
            waveAmplitude: 5.0,
            noiseScale: 2.0,
            distortion: 0.3,
            distortionStyle: 'smooth',
            animationDirection: 'radial',
            size: 1.5,
            mode: '3d', // '3d', 'full', 'smooth', 'fluid', or 'mogi'
            imageTexture: null,
            imageOpacity: 0.7,
            // 3D mode specific
            shape: 'sphere', // 'sphere', 'torus', or 'cube'
            colorBlend: 1.0, // Controls tightness of color transitions
            // Fluid mode specific
            waveDirection: 'horizontal',
            waveFreqX: 4.0,
            waveFreqY: 4.0,
            horizontalPressure: 5.0,
            verticalPressure: 5.0,
            // MOGI mode specific
            mogi: {
                headColor: '#FFD93D',
                headSize: 2.0,
                leftEye: {
                    shape: 'circle',
                    color: '#000000',
                    size: 0.2
                },
                rightEye: {
                    shape: 'circle',
                    color: '#000000',
                    size: 0.2
                },
                mouth: {
                    shape: 'curved-up',
                    color: '#FF0000',
                    size: 0.3
                }
            }
        };
        
        // Distortion presets - original values for 3D mode
        const distortionPresets = {
            smooth: { distortion: 0.3, noiseScale: 2.0, speed: 0.5, timeMultiplier: 0.5 },
            waves: { distortion: 0.4, noiseScale: 1.2, speed: 0.7, timeMultiplier: 0.8 },
            liquid: { distortion: 0.5, noiseScale: 1.5, speed: 0.8, timeMultiplier: 1.0 },
            turbulent: { distortion: 0.4, noiseScale: 3.5, speed: 0.6, timeMultiplier: 0.7 },
            minimal: { distortion: 0.15, noiseScale: 1.8, speed: 0.4, timeMultiplier: 0.4 }
        };
        
        // Gentler presets for Torus to avoid jaggedness
        const torusDistortionPresets = {
            smooth: { distortion: 0.25, noiseScale: 1.5, speed: 0.5, timeMultiplier: 0.5 },
            waves: { distortion: 0.3, noiseScale: 1.0, speed: 0.7, timeMultiplier: 0.8 },
            liquid: { distortion: 0.4, noiseScale: 1.2, speed: 0.8, timeMultiplier: 1.0 },
            turbulent: { distortion: 0.3, noiseScale: 2.5, speed: 0.6, timeMultiplier: 0.7 },
            minimal: { distortion: 0.1, noiseScale: 1.5, speed: 0.4, timeMultiplier: 0.4 }
        };
        
        // Animation direction mapping
        const directionMap = {
            radial: 0,
            horizontal: 1,
            vertical: 2,
            diagonal: 3,
            spiral: 4
        };
        
        // Mood presets - comprehensive settings for each emotional theme
        const moodPresets = {
            happy: {
                colors: ['#FFD700', '#FF69B4', '#00CED1', '#FFA500'], // Gold, Hot Pink, Turquoise, Orange
                speed: 1.2,
                colorBlend: 1.5,
                noiseScale: 2.5,
                distortionStyle: 'liquid',
                animationDirection: 'radial',
                waveAmplitude: 7.0,
                waveFreqX: 5.0,
                waveFreqY: 5.0,
                horizontalPressure: 6.0,
                verticalPressure: 6.0,
                waveDirection: 'diagonal'
            },
            chill: {
                colors: ['#4A90E2', '#7B68EE', '#48D1CC'], // Soft Blue, Medium Purple, Medium Turquoise
                speed: 0.3,
                colorBlend: 2.5,
                noiseScale: 1.5,
                distortionStyle: 'smooth',
                animationDirection: 'horizontal',
                waveAmplitude: 4.0,
                waveFreqX: 3.0,
                waveFreqY: 3.0,
                horizontalPressure: 4.0,
                verticalPressure: 4.0,
                waveDirection: 'horizontal'
            },
            rage: {
                colors: ['#FF0000', '#FF4500', '#8B0000'], // Pure Red, Orange Red, Dark Red
                speed: 2.0,
                colorBlend: 0.5,
                noiseScale: 4.5,
                distortionStyle: 'turbulent',
                animationDirection: 'spiral',
                waveAmplitude: 10.0,
                waveFreqX: 8.0,
                waveFreqY: 8.0,
                horizontalPressure: 9.0,
                verticalPressure: 9.0,
                waveDirection: 'diagonal'
            },
            energetic: {
                colors: ['#FF1493', '#00FF00', '#FFD700', '#FF4500'], // Deep Pink, Lime, Gold, Orange Red
                speed: 1.5,
                colorBlend: 0.8,
                noiseScale: 3.5,
                distortionStyle: 'waves',
                animationDirection: 'diagonal',
                waveAmplitude: 8.0,
                waveFreqX: 6.0,
                waveFreqY: 6.0,
                horizontalPressure: 7.0,
                verticalPressure: 7.0,
                waveDirection: 'horizontal'
            }
        };
        
        function applyMoodPreset(moodName) {
            const preset = moodPresets[moodName];
            if (!preset) return;
            
            // Apply colors
            config.colors = [...preset.colors];
            rebuildColorUI();
            
            // Apply animation settings
            config.speed = preset.speed;
            document.getElementById('speed').value = preset.speed;
            document.getElementById('speedValue').textContent = preset.speed.toFixed(1);
            
            // Apply 3D mode settings
            config.colorBlend = preset.colorBlend;
            const colorBlendSlider = document.getElementById('colorBlend');
            if (colorBlendSlider) {
                colorBlendSlider.value = preset.colorBlend;
                document.getElementById('colorBlendValue').textContent = preset.colorBlend.toFixed(1);
            }
            
            // Apply noise and distortion
            config.noiseScale = preset.noiseScale;
            document.getElementById('noiseScale').value = preset.noiseScale;
            document.getElementById('noiseScaleValue').textContent = preset.noiseScale.toFixed(1);
            
            config.distortionStyle = preset.distortionStyle;
            const distortionPreset = distortionPresets[preset.distortionStyle];
            config.distortion = distortionPreset.distortion;
            
            // Update distortion buttons
            document.querySelectorAll('.distortion-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.distortion-btn[data-style="${preset.distortionStyle}"]`)?.classList.add('active');
            
            // Apply animation direction
            config.animationDirection = preset.animationDirection;
            document.querySelectorAll('.direction-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.direction-btn[data-direction="${preset.animationDirection}"]`)?.classList.add('active');
            
            // Apply SMOOTH mode settings
            config.waveAmplitude = preset.waveAmplitude;
            const waveAmpSlider = document.getElementById('waveAmplitude');
            if (waveAmpSlider) {
                waveAmpSlider.value = preset.waveAmplitude;
                document.getElementById('waveAmplitudeValue').textContent = preset.waveAmplitude.toFixed(1);
            }
            
            // Apply FLUID mode settings
            config.waveFreqX = preset.waveFreqX;
            config.waveFreqY = preset.waveFreqY;
            config.horizontalPressure = preset.horizontalPressure;
            config.verticalPressure = preset.verticalPressure;
            config.waveDirection = preset.waveDirection;
            
            const waveFreqXSlider = document.getElementById('waveFreqX');
            if (waveFreqXSlider) {
                waveFreqXSlider.value = preset.waveFreqX;
                document.getElementById('waveFreqXValue').textContent = preset.waveFreqX.toFixed(1);
            }
            
            const waveFreqYSlider = document.getElementById('waveFreqY');
            if (waveFreqYSlider) {
                waveFreqYSlider.value = preset.waveFreqY;
                document.getElementById('waveFreqYValue').textContent = preset.waveFreqY.toFixed(1);
            }
            
            const horizPressSlider = document.getElementById('horizontalPressure');
            if (horizPressSlider) {
                horizPressSlider.value = preset.horizontalPressure;
                document.getElementById('horizontalPressureValue').textContent = preset.horizontalPressure.toFixed(1);
            }
            
            const vertPressSlider = document.getElementById('verticalPressure');
            if (vertPressSlider) {
                vertPressSlider.value = preset.verticalPressure;
                document.getElementById('verticalPressureValue').textContent = preset.verticalPressure.toFixed(1);
            }
            
            const waveDirSelect = document.getElementById('waveDirection');
            if (waveDirSelect) {
                waveDirSelect.value = preset.waveDirection;
            }
            
            // Recreate mesh with new settings
            createMesh();
        }

        let scene, camera, renderer, mesh;
        let time = 0;
        let currentColorIndex = null; // Track which color is being edited
        
        // Mouse/touch interaction variables
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotation = { x: 0, y: 0 };
        let targetRotation = { x: 0, y: 0 };
        let autoRotate = true;

        // Combined vertex shader for all modes
        const vertexShader = `
            uniform float uTime;
            uniform float uNoiseScale;
            uniform float uDistortion;
            uniform float uTimeMultiplier;
            uniform int uAnimationDirection;
            uniform float uWaveAmplitude;
            uniform bool uIsNeatMode;
            uniform bool uIsFluidMode;
            uniform float uWaveFreqX;
            uniform float uWaveFreqY;
            uniform float uHorizontalPressure;
            uniform float uVerticalPressure;
            uniform int uWaveDirection;
            uniform bool uIsFullMode;
            uniform bool uIsTorus;
            uniform bool uIsLiquidStyle;
            
            varying vec3 vPosition;
            varying vec3 vNormal;
            varying vec2 vUv;
            
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            
            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                
                vec3 i  = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy);
                vec3 i2 = max(g.xyz, l.zxy);
                
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                
                i = mod289(i);
                vec4 p = permute(permute(permute(
                    i.z + vec4(0.0, i1.z, i2.z, 1.0))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                
                float n_ = 0.142857142857;
                vec3 ns = n_ * D.wyz - D.xzx;
                
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_);
                
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                
                vec4 b0 = vec4(x.xy, y.xy);
                vec4 b1 = vec4(x.zw, y.zw);
                
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                
                vec3 p0 = vec3(a0.xy, h.x);
                vec3 p1 = vec3(a0.zw, h.y);
                vec3 p2 = vec3(a1.xy, h.z);
                vec3 p3 = vec3(a1.zw, h.w);
                
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;
                
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }
            
            void main() {
                vPosition = position;
                vNormal = normal;
                vUv = uv;
                
                vec3 pos = position;
                
                if (uIsFluidMode) {
                    // FLUID MODE: Complex wave patterns
                    float t = uTime * uTimeMultiplier;
                    float pressureX = uHorizontalPressure * 0.3;
                    float pressureY = uVerticalPressure * 0.3;
                    
                    float wave1, wave2, wave3, wave4, wave5, wave6;
                    
                    if (uWaveDirection == 0) { // Horizontal
                        wave1 = sin(pos.x * uWaveFreqX * 0.5 - t * 2.0) * pressureX;
                        wave2 = sin(pos.x * uWaveFreqX * 0.7 - t * 1.5) * pressureX * 0.6;
                        wave3 = cos(pos.y * uWaveFreqY * 0.5 - t * 0.5) * pressureY * 0.3;
                        wave4 = sin(pos.y * uWaveFreqY * 0.6 + t * 0.3) * pressureY * 0.4;
                        wave5 = sin((pos.x + pos.y) * uWaveFreqX * 0.3 - t * 1.3) * pressureX * 0.4;
                        wave6 = cos((pos.x - pos.y) * uWaveFreqY * 0.35 - t * 1.0) * pressureY * 0.3;
                    } else if (uWaveDirection == 1) { // Vertical
                        wave1 = sin(pos.y * uWaveFreqY * 0.5 + t * 2.0) * pressureY;
                        wave2 = sin(pos.y * uWaveFreqY * 0.7 + t * 1.5) * pressureY * 0.6;
                        wave3 = cos(pos.x * uWaveFreqX * 0.5 + t * 0.5) * pressureX * 0.3;
                        wave4 = sin(pos.x * uWaveFreqX * 0.6 - t * 0.3) * pressureX * 0.4;
                        wave5 = sin((pos.x + pos.y) * uWaveFreqY * 0.3 + t * 1.3) * pressureY * 0.4;
                        wave6 = cos((pos.x - pos.y) * uWaveFreqX * 0.35 + t * 1.0) * pressureX * 0.3;
                    } else { // Diagonal
                        wave1 = sin((pos.x + pos.y) * uWaveFreqX * 0.4 - t * 2.0) * pressureX;
                        wave2 = sin((pos.x + pos.y) * uWaveFreqX * 0.6 - t * 1.5) * pressureX * 0.6;
                        wave3 = cos((pos.x - pos.y) * uWaveFreqY * 0.4 - t * 1.8) * pressureY;
                        wave4 = sin((pos.y - pos.x * 0.5) * uWaveFreqY * 0.5 - t * 1.3) * pressureY * 0.7;
                        wave5 = sin(pos.x * uWaveFreqX * 0.3 - pos.y * 0.2 - t * 1.6) * pressureX * 0.4;
                        wave6 = cos(pos.y * uWaveFreqY * 0.35 - pos.x * 0.3 - t * 1.4) * pressureY * 0.4;
                    }
                    
                    float displacement = (wave1 + wave2 + wave3 + wave4 + wave5 + wave6) * uWaveAmplitude * 0.05;
                    pos.z = displacement;
                    
                } else if (uIsNeatMode) {
                    // SMOOTH MODE: Horizontal flowing waves (left to right)
                    float wave1 = sin(pos.x * 2.0 - uTime * uTimeMultiplier * 3.0) * uWaveAmplitude * 0.08;
                    float wave2 = sin(pos.x * 3.0 - uTime * uTimeMultiplier * 2.5) * uWaveAmplitude * 0.05;
                    float wave3 = cos(pos.y * 2.5 - uTime * uTimeMultiplier * 2.0) * uWaveAmplitude * 0.06;
                    
                    // Combine waves for flowing motion
                    pos.z += wave1 + wave2 + wave3;
                    pos.y += wave1 * 0.3;
                    
                } else {
                    // 3D/FULL MODE: Different handling based on mode
                    vec3 noiseInput = pos * uNoiseScale;
                    
                    // Calculate animation offset based on direction
                    if (uAnimationDirection == 0) {
                        // Radial
                        float dist = length(pos);
                        noiseInput += vec3(uTime * uTimeMultiplier * dist * 0.3);
                    } else if (uAnimationDirection == 1) {
                        // Horizontal
                        noiseInput.x += uTime * uTimeMultiplier * 2.0;
                    } else if (uAnimationDirection == 2) {
                        // Vertical
                        noiseInput.y += uTime * uTimeMultiplier * 2.0;
                    } else if (uAnimationDirection == 3) {
                        // Diagonal
                        noiseInput.x += uTime * uTimeMultiplier * 1.4;
                        noiseInput.y += uTime * uTimeMultiplier * 1.4;
                    } else if (uAnimationDirection == 4) {
                        // Spiral
                        float angle = uTime * uTimeMultiplier;
                        float dist = length(pos.xy);
                        noiseInput += vec3(cos(angle) * dist * 0.5, sin(angle) * dist * 0.5, angle * 0.3);
                    }
                    
                    // Special tube variation for Torus with Liquid style (lava lamp effect)
                    if (uIsTorus && uIsLiquidStyle) {
                        // Get the angle around the main torus ring
                        float mainAngle = atan(pos.y, pos.x);
                        
                        // Calculate the tube center position on the main ring
                        float ringRadius = 1.5; // Main torus radius
                        vec3 ringCenter = vec3(cos(mainAngle) * ringRadius, sin(mainAngle) * ringRadius, 0.0);
                        
                        // Vector from ring center to current vertex (tube direction)
                        vec3 toVertex = pos - ringCenter;
                        float currentTubeRadius = length(toVertex);
                        vec3 tubeDirection = normalize(toVertex);
                        
                        // Intensity control - scale up for more dramatic effect
                        float intensity = uNoiseScale * 0.33;
                        
                        // Use sine/cosine directly with the angle for perfect continuity
                        // These functions are inherently continuous around the circle
                        
                        // Primary smooth wave - 2 lobes
                        float wave1 = (cos(mainAngle * 2.0 - uTime * 0.4) + 1.0) * 0.5;
                        
                        // Secondary wave - 3 lobes  
                        float wave2 = (cos(mainAngle * 3.0 + uTime * 0.3) + 1.0) * 0.5;
                        
                        // Base wave - 1 lobe for overall shape
                        float baseWave = (cos(mainAngle - uTime * 0.2) + 1.0) * 0.5;
                        
                        // Blend the waves
                        float pattern = baseWave * 0.4 + wave1 * 0.35 + wave2 * 0.25;
                        
                        // Add gentle 3D variation around the tube
                        float tubeAngle = atan(toVertex.z, length(toVertex.xy) - ringRadius);
                        float tubeVar = (cos(tubeAngle * 2.0) + 1.0) * 0.5;
                        
                        // Subtle blend with tube variation
                        pattern = pattern * 0.9 + tubeVar * 0.1;
                        
                        // Smooth the pattern using cosine interpolation
                        pattern = (cos((1.0 - pattern) * 3.14159) + 1.0) * 0.5;
                        
                        // Dynamic radius range based on intensity
                        // At max intensity (3.0), range from 0.4 to 1.6 (40% to 160%)
                        // At min intensity (0.0), range is 1.0 (no change)
                        float effectStrength = intensity; // 0 to 1 when slider is 0 to 3
                        
                        // Interpolate min/max radius based on intensity
                        float minRadius = mix(1.0, 0.4, effectStrength);
                        float maxRadius = mix(1.0, 1.6, effectStrength);
                        
                        float radiusModulation = minRadius + (maxRadius - minRadius) * pattern;
                        
                        // Ensure smooth application
                        float newRadius = currentTubeRadius * radiusModulation;
                        
                        // Apply the deformation
                        pos = ringCenter + tubeDirection * newRadius;
                    } else if (uIsFullMode) {
                        // FULL MODE: Smoother multi-octave noise for better edges
                        float noise = 0.0;
                        float amplitude = 1.0;
                        float frequency = 1.0;
                        
                        // Add multiple octaves for smoother results
                        for (int i = 0; i < 4; i++) {
                            noise += snoise(noiseInput * frequency) * amplitude;
                            amplitude *= 0.5;
                            frequency *= 1.8;
                        }
                        
                        // Normalize and smooth
                        noise = noise * 0.5;
                        noise = smoothstep(-1.0, 1.0, noise);
                        
                        // Apply edge falloff for smooth boundaries
                        float edgeFalloff = 1.0;
                        float distFromCenter = length(pos.xy);
                        if (distFromCenter > 2.5) {
                            edgeFalloff = smoothstep(4.5, 2.5, distFromCenter);
                        }
                        
                        // Reduce distortion slightly to prevent harsh transitions
                        pos += normal * noise * uDistortion * 0.6 * edgeFalloff;
                    } else if (!uIsTorus || !uIsLiquidStyle) {
                        // 3D MODE: Only apply normal distortion if NOT torus+liquid
                        float noise = snoise(noiseInput);
                        
                        // Apply gentler distortion for Torus to avoid jagged edges
                        if (uIsTorus) {
                            // Smooth the noise for torus
                            noise = smoothstep(-1.0, 1.0, noise) * 0.8;
                            
                            // Reduce distortion strength for torus
                            pos += normal * noise * uDistortion * 0.7;
                        } else {
                            // Original distortion for sphere
                            pos += normal * noise * uDistortion;
                        }
                    }
                }
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        // Fragment shader with FLUID mode support and improved 3D gradients
        const fragmentShader = `
            uniform vec3 uColor1;
            uniform vec3 uColor2;
            uniform vec3 uColor3;
            uniform vec3 uColor4;
            uniform bool uHasColor4;
            uniform float uTime;
            uniform sampler2D uTexture;
            uniform bool uHasTexture;
            uniform float uImageOpacity;
            uniform bool uIsFluidMode;
            uniform float uWaveFreqX;
            uniform float uWaveFreqY;
            uniform int uWaveDirection;
            uniform float uTimeMultiplier;
            uniform int uAnimationDirection;
            uniform bool uIsNeatMode;
            uniform float uColorBlend;
            
            varying vec3 vPosition;
            varying vec3 vNormal;
            varying vec2 vUv;
            
            void main() {
                vec3 color;
                
                if (uIsFluidMode) {
                    // FLUID MODE: Dynamic color mixing based on position and time
                    float t = uTime * uTimeMultiplier;
                    
                    float mix1, mix2, mix3, mix4, mix5;
                    
                    if (uWaveDirection == 0) { // Horizontal
                        mix1 = sin(vPosition.x * uWaveFreqX * 0.5 - t * 2.0) * 0.5 + 0.5;
                        mix2 = cos(vPosition.x * uWaveFreqX * 0.6 - t * 1.8) * 0.5 + 0.5;
                        mix3 = sin((vPosition.x + vPosition.y * 0.3) * uWaveFreqX * 0.4 - t * 1.5) * 0.5 + 0.5;
                        mix4 = cos((vPosition.x - vPosition.y * 0.2) * uWaveFreqX * 0.45 - t * 1.3) * 0.5 + 0.5;
                        mix5 = sin(vPosition.x * uWaveFreqX * 0.55 - vPosition.y * 0.3 - t * 1.7) * 0.5 + 0.5;
                    } else if (uWaveDirection == 1) { // Vertical
                        mix1 = sin(vPosition.y * uWaveFreqY * 0.5 + t * 2.0) * 0.5 + 0.5;
                        mix2 = cos(vPosition.y * uWaveFreqY * 0.6 + t * 1.8) * 0.5 + 0.5;
                        mix3 = sin((vPosition.y + vPosition.x * 0.3) * uWaveFreqY * 0.4 + t * 1.5) * 0.5 + 0.5;
                        mix4 = cos((vPosition.y - vPosition.x * 0.2) * uWaveFreqY * 0.45 + t * 1.3) * 0.5 + 0.5;
                        mix5 = sin(vPosition.y * uWaveFreqY * 0.55 - vPosition.x * 0.3 + t * 1.7) * 0.5 + 0.5;
                    } else { // Diagonal
                        mix1 = sin((vPosition.x + vPosition.y) * uWaveFreqX * 0.4 - t * 2.0) * 0.5 + 0.5;
                        mix2 = cos((vPosition.x + vPosition.y) * uWaveFreqX * 0.5 - t * 1.8) * 0.5 + 0.5;
                        mix3 = sin((vPosition.x - vPosition.y) * uWaveFreqY * 0.35 - t * 1.5) * 0.5 + 0.5;
                        mix4 = cos((vPosition.y - vPosition.x * 0.5) * uWaveFreqY * 0.4 - t * 1.3) * 0.5 + 0.5;
                        mix5 = sin((vPosition.x * 0.6 + vPosition.y * 0.4) * uWaveFreqX * 0.45 - t * 1.7) * 0.5 + 0.5;
                    }
                    
                    // Blend all colors with independent mix factors - balanced brightness
                    color = uColor1 * mix1;
                    color += uColor2 * mix2;
                    color += uColor3 * mix3;
                    
                    if (uHasColor4) {
                        color += uColor4 * mix4;
                        color *= 0.35; // Balanced for 4 colors
                    } else {
                        color *= 0.42; // Balanced for 3 colors
                    }
                    
                    // Moderate saturation boost for rich but natural colors
                    float maxComponent = max(max(color.r, color.g), color.b);
                    if (maxComponent > 0.0) {
                        color = mix(color, color / maxComponent, 0.15); // Gentle saturation boost
                    }
                    color = color * 1.15; // Moderate brightness adjustment without offset to prevent blown highlights
                    
                    // Add subtle lighting based on Z displacement
                    float lighting = 1.0 + vPosition.z * 0.25;
                    color *= lighting;
                    
                } else if (!uIsNeatMode) {
                    // 3D/FULL MODE: Direction-based color gradients
                    float animated = sin(uTime * 0.5) * 0.5 + 0.5;
                    
                    if (uAnimationDirection == 0) {
                        // RADIAL: Colors radiate from center outward
                        float distFromCenter = length(vPosition);
                        float normalizedDist = smoothstep(0.0, 2.0, distFromCenter);
                        
                        // Animate the gradient bands moving outward
                        float animatedDist = mod(normalizedDist - uTime * 0.1, 1.0);
                        
                        // Create color bands radiating from center with blend control
                        if (uHasColor4) {
                            float band = animatedDist * 4.0;
                            float blendSharpness = uColorBlend;
                            
                            if (band < 1.0) {
                                float t = smoothstep(0.5 - blendSharpness * 0.5, 0.5 + blendSharpness * 0.5, band);
                                color = mix(uColor1, uColor2, t);
                            } else if (band < 2.0) {
                                float t = smoothstep(0.5 - blendSharpness * 0.5, 0.5 + blendSharpness * 0.5, band - 1.0);
                                color = mix(uColor2, uColor3, t);
                            } else if (band < 3.0) {
                                float t = smoothstep(0.5 - blendSharpness * 0.5, 0.5 + blendSharpness * 0.5, band - 2.0);
                                color = mix(uColor3, uColor4, t);
                            } else {
                                float t = smoothstep(0.5 - blendSharpness * 0.5, 0.5 + blendSharpness * 0.5, band - 3.0);
                                color = mix(uColor4, uColor1, t);
                            }
                        } else {
                            float band = animatedDist * 3.0;
                            float blendSharpness = uColorBlend;
                            
                            if (band < 1.0) {
                                float t = smoothstep(0.5 - blendSharpness * 0.5, 0.5 + blendSharpness * 0.5, band);
                                color = mix(uColor1, uColor2, t);
                            } else if (band < 2.0) {
                                float t = smoothstep(0.5 - blendSharpness * 0.5, 0.5 + blendSharpness * 0.5, band - 1.0);
                                color = mix(uColor2, uColor3, t);
                            } else {
                                float t = smoothstep(0.5 - blendSharpness * 0.5, 0.5 + blendSharpness * 0.5, band - 2.0);
                                color = mix(uColor3, uColor1, t);
                            }
                        }
                        
                    } else if (uAnimationDirection == 1) {
                        // HORIZONTAL: Gradient flows left to right
                        float xNorm = (vPosition.x + 1.5) / 3.0;
                        float animPos = mod(xNorm + uTime * 0.1, 1.0);
                        
                        float blendWidth = 1.0 / uColorBlend;
                        
                        if (uHasColor4) {
                            float segment = animPos * 4.0;
                            if (segment < 1.0) {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment);
                                color = mix(uColor1, uColor2, t);
                            } else if (segment < 2.0) {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment - 1.0);
                                color = mix(uColor2, uColor3, t);
                            } else if (segment < 3.0) {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment - 2.0);
                                color = mix(uColor3, uColor4, t);
                            } else {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment - 3.0);
                                color = mix(uColor4, uColor1, t);
                            }
                        } else {
                            float segment = animPos * 3.0;
                            if (segment < 1.0) {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment);
                                color = mix(uColor1, uColor2, t);
                            } else if (segment < 2.0) {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment - 1.0);
                                color = mix(uColor2, uColor3, t);
                            } else {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment - 2.0);
                                color = mix(uColor3, uColor1, t);
                            }
                        }
                        
                    } else if (uAnimationDirection == 2) {
                        // VERTICAL: Gradient flows bottom to top
                        float yNorm = (vPosition.y + 1.5) / 3.0;
                        float animPos = mod(yNorm + uTime * 0.1, 1.0);
                        
                        float blendWidth = 1.0 / uColorBlend;
                        
                        if (uHasColor4) {
                            float segment = animPos * 4.0;
                            if (segment < 1.0) {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment);
                                color = mix(uColor1, uColor2, t);
                            } else if (segment < 2.0) {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment - 1.0);
                                color = mix(uColor2, uColor3, t);
                            } else if (segment < 3.0) {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment - 2.0);
                                color = mix(uColor3, uColor4, t);
                            } else {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment - 3.0);
                                color = mix(uColor4, uColor1, t);
                            }
                        } else {
                            float segment = animPos * 3.0;
                            if (segment < 1.0) {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment);
                                color = mix(uColor1, uColor2, t);
                            } else if (segment < 2.0) {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment - 1.0);
                                color = mix(uColor2, uColor3, t);
                            } else {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment - 2.0);
                                color = mix(uColor3, uColor1, t);
                            }
                        }
                        
                    } else if (uAnimationDirection == 3) {
                        // DIAGONAL: Gradient flows diagonally
                        float diagNorm = (vPosition.x + vPosition.y + 3.0) / 6.0;
                        float animPos = mod(diagNorm + uTime * 0.1, 1.0);
                        
                        float blendWidth = 1.0 / uColorBlend;
                        
                        if (uHasColor4) {
                            float segment = animPos * 4.0;
                            if (segment < 1.0) {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment);
                                color = mix(uColor1, uColor2, t);
                            } else if (segment < 2.0) {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment - 1.0);
                                color = mix(uColor2, uColor3, t);
                            } else if (segment < 3.0) {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment - 2.0);
                                color = mix(uColor3, uColor4, t);
                            } else {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment - 3.0);
                                color = mix(uColor4, uColor1, t);
                            }
                        } else {
                            float segment = animPos * 3.0;
                            if (segment < 1.0) {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment);
                                color = mix(uColor1, uColor2, t);
                            } else if (segment < 2.0) {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment - 1.0);
                                color = mix(uColor2, uColor3, t);
                            } else {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment - 2.0);
                                color = mix(uColor3, uColor1, t);
                            }
                        }
                        
                    } else if (uAnimationDirection == 4) {
                        // SPIRAL: Colors spiral around the form
                        float angle = atan(vPosition.y, vPosition.x);
                        float radius = length(vPosition.xy);
                        float spiral = mod(angle / (2.0 * 3.14159) + radius * 0.5 - uTime * 0.2, 1.0);
                        
                        float blendWidth = 1.0 / uColorBlend;
                        
                        if (uHasColor4) {
                            float segment = spiral * 4.0;
                            if (segment < 1.0) {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment);
                                color = mix(uColor1, uColor2, t);
                            } else if (segment < 2.0) {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment - 1.0);
                                color = mix(uColor2, uColor3, t);
                            } else if (segment < 3.0) {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment - 2.0);
                                color = mix(uColor3, uColor4, t);
                            } else {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment - 3.0);
                                color = mix(uColor4, uColor1, t);
                            }
                        } else {
                            float segment = spiral * 3.0;
                            if (segment < 1.0) {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment);
                                color = mix(uColor1, uColor2, t);
                            } else if (segment < 2.0) {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment - 1.0);
                                color = mix(uColor2, uColor3, t);
                            } else {
                                float t = smoothstep(0.5 - blendWidth * 0.5, 0.5 + blendWidth * 0.5, segment - 2.0);
                                color = mix(uColor3, uColor1, t);
                            }
                        }
                    }
                    
                    // Apply subtle saturation enhancement for richer colors
                    float maxComp = max(max(color.r, color.g), color.b);
                    if (maxComp > 0.0 && maxComp < 1.0) {
                        color = mix(color, color / maxComp, 0.08); // Very subtle saturation boost
                    }
                    
                    // Apply lighting
                    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                    float lightIntensity = dot(vNormal, lightDir) * 0.3 + 0.7;
                    color *= lightIntensity;
                    
                } else {
                    // SMOOTH mode: Keep original implementation
                    float mixValue1 = (vPosition.y + 1.0) * 0.5;
                    float mixValue2 = (vPosition.x + 1.0) * 0.5;
                    float animated = sin(uTime * 0.5 + vPosition.z) * 0.5 + 0.5;
                    
                    color = mix(uColor1, uColor2, mixValue1);
                    color = mix(color, uColor3, mixValue2 * animated);
                    
                    if (uHasColor4) {
                        float mixValue3 = (vPosition.z + 1.0) * 0.5;
                        color = mix(color, uColor4, mixValue3 * 0.3);
                    }
                    
                    // Apply subtle saturation enhancement for richer colors
                    float maxComp = max(max(color.r, color.g), color.b);
                    if (maxComp > 0.0 && maxComp < 1.0) {
                        color = mix(color, color / maxComp, 0.08); // Very subtle saturation boost
                    }
                    
                    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                    float lightIntensity = dot(vNormal, lightDir) * 0.3 + 0.7;
                    color *= lightIntensity;
                }
                
                // Blend with image texture if available
                if (uHasTexture) {
                    vec4 texColor = texture2D(uTexture, vUv);
                    color = mix(color, texColor.rgb, texColor.a * uImageOpacity);
                }
                
                // Soft clamp to prevent blown highlights while preserving color relationships
                float maxVal = max(max(color.r, color.g), color.b);
                if (maxVal > 1.0) {
                    color = color / maxVal * 0.95; // Soft clamp with slight reduction
                }
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16) / 255,
                g: parseInt(result[2], 16) / 255,
                b: parseInt(result[3], 16) / 255
            } : { r: 1, g: 1, b: 1 };
        }
        
        function getWaveDirectionValue(direction) {
            const directions = { horizontal: 0, vertical: 1, diagonal: 2 };
            return directions[direction] || 0;
        }
        
        function rebuildColorUI() {
            const colorCircles = document.getElementById('colorCircles');
            const addBtn = document.getElementById('addColorBtn');
            
            // Clear existing color items (but keep add button)
            const items = colorCircles.querySelectorAll('.color-item');
            items.forEach(item => item.remove());
            
            // Rebuild color items
            config.colors.forEach((color, index) => {
                const colorItem = document.createElement('div');
                colorItem.className = 'color-item';
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.setAttribute('data-index', index);
                deleteBtn.textContent = '−';
                deleteBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const idx = parseInt(this.getAttribute('data-index'));
                    if (config.colors.length <= 2) return;
                    config.colors.splice(idx, 1);
                    rebuildColorUI();
                    createMesh();
                });
                
                const colorCircle = document.createElement('div');
                colorCircle.className = 'color-circle';
                colorCircle.setAttribute('data-index', index);
                colorCircle.style.backgroundColor = color;
                colorCircle.addEventListener('click', function() {
                    const idx = parseInt(this.getAttribute('data-index'));
                    currentColorIndex = idx;
                    
                    // Get current color and update custom picker
                    const currentColor = config.colors[idx];
                    mainColorPickerUpdate(currentColor);
                    
                    // Position popup over the colors section (where red box is shown)
                    const popup = document.getElementById('colorPickerPopup');
                    const colorsSection = document.querySelector('.color-swatches');
                    const controlsPanel = document.querySelector('.controls');
                    if (popup && colorsSection && controlsPanel) {
                        const colorsRect = colorsSection.getBoundingClientRect();
                        const controlsRect = controlsPanel.getBoundingClientRect();
                        const maxPopupWidth = Math.min(280, controlsRect.width - 20); // Never exceed editor width minus padding
                        const maxPopupHeight = Math.min(400, controlsRect.height - 20); // Never exceed editor height minus padding
                        
                        // Set max dimensions to ensure popup never exceeds editor bounds
                        popup.style.maxWidth = maxPopupWidth + 'px';
                        popup.style.maxHeight = maxPopupHeight + 'px';
                        
                        // Get actual popup dimensions (will be constrained by max-width/max-height)
                        const popupWidth = Math.min(260, maxPopupWidth);
                        const popupHeight = Math.min(400, maxPopupHeight);
                        
                        // Position popup centered over the colors section
                        let leftPos = colorsRect.left + (colorsRect.width / 2) - (popupWidth / 2);
                        let topPos = colorsRect.top + (colorsRect.height / 2) - (popupHeight / 2);
                        
                        // Ensure popup stays completely within editor bounds
                        if (leftPos < controlsRect.left) {
                            leftPos = controlsRect.left + 10;
                        }
                        if (leftPos + popupWidth > controlsRect.right) {
                            leftPos = controlsRect.right - popupWidth - 10;
                        }
                        if (topPos < controlsRect.top) {
                            topPos = controlsRect.top + 10;
                        }
                        if (topPos + popupHeight > controlsRect.bottom) {
                            topPos = controlsRect.bottom - popupHeight - 10;
                        }
                        
                        popup.style.left = leftPos + 'px';
                        popup.style.top = topPos + 'px';
                        popup.style.right = 'auto';
                        popup.style.transform = 'none';
                    } else {
                        console.error('Missing elements in rebuildColorUI:', { popup, colorsSection, controlsPanel });
                        // Fallback: show popup anyway, centered in viewport
                        if (popup) {
                            popup.style.left = '50%';
                            popup.style.top = '50%';
                            popup.style.transform = 'translate(-50%, -50%)';
                        }
                    }
                    
                    // Show popup - ALWAYS show it
                    const popupElement = document.getElementById('colorPickerPopup');
                    if (popupElement) {
                        popupElement.classList.add('show');
                        // Force display in case CSS isn't working
                        popupElement.style.display = 'block';
                        console.log('Showing popup from rebuildColorUI');
                    } else {
                        console.error('Popup element not found in rebuildColorUI!');
                    }
                    document.querySelectorAll('.color-circle').forEach(c => c.classList.remove('active'));
                    this.classList.add('active');
                });
                
                colorItem.appendChild(deleteBtn);
                colorItem.appendChild(colorCircle);
                colorCircles.insertBefore(colorItem, addBtn);
            });
            
            // Update add button state
            if (config.colors.length >= 4) {
                addBtn.classList.add('disabled');
                addBtn.style.pointerEvents = 'none';
            } else {
                addBtn.classList.remove('disabled');
                addBtn.style.pointerEvents = 'auto';
            }
        }
        
        function updateBackgroundColor(color) {
            config.backgroundColor = color;
            const rgb = hexToRgb(color);
            if (scene && scene.background) {
                scene.background.setRGB(rgb.r, rgb.g, rgb.b);
            }
        }

        function init() {
            status.textContent = 'Initializing scene...';
            
            scene = new THREE.Scene();
            
            // Set background color
            const bgColor = hexToRgb(config.backgroundColor);
            scene.background = new THREE.Color(bgColor.r, bgColor.g, bgColor.b);
            
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            updateCameraPosition();
            
            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            createMesh();
            
            setupControls();
            setupModeButtons();
            setupInteraction();
            window.addEventListener('resize', onWindowResize);
            
            status.textContent = 'Running!';
            setTimeout(() => status.style.display = 'none', 2000);
            
            // Show interaction hint for 3D mode
            if (config.mode === '3d') {
                document.getElementById('interactionHint').classList.add('show');
            }
            
            animate();
        }
        
        function updateCameraPosition() {
            if (config.mode === '3d') {
                camera.position.z = 5;
            } else if (config.mode === 'smooth') {
                camera.position.z = 1.5;
            } else if (config.mode === 'fluid') {
                camera.position.z = 3;
            } else if (config.mode === 'mogi') {
                camera.position.z = 6;
            } else {
                camera.position.z = 1.5;
            }
        }
        
        function createMesh() {
            // Remove old mesh if it exists
            if (mesh) {
                scene.remove(mesh);
                mesh.geometry.dispose();
                mesh.material.dispose();
            }
            
            // Completely remove ALL mogiGroup instances from scene (when switching away from MOGI mode)
            // Search through scene children and remove any mogiGroup
            const childrenToRemove = [];
            scene.traverse((obj) => {
                if (obj.name === 'mogiGroup') {
                    childrenToRemove.push(obj);
                }
            });
            
            childrenToRemove.forEach((group) => {
                scene.remove(group);
                group.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            });
            
            let geometry;
            if (config.mode === '3d') {
                // Different geometries based on selected shape
                if (config.shape === 'torus') {
                    // Torus with much higher subdivision for smoother distortion
                    // Parameters: radius, tube radius, radial segments, tubular segments
                    geometry = new THREE.TorusGeometry(
                        config.size,        // Main radius
                        config.size * 0.4,  // Tube radius (40% of main)
                        100,                // Radial segments (increased more)
                        200                 // Tubular segments (increased more)
                    );
                } else {
                    // Default sphere (icosahedron for smooth look) - UNCHANGED
                    geometry = new THREE.IcosahedronGeometry(config.size, 64);
                }
            } else if (config.mode === 'fluid') {
                geometry = new THREE.PlaneGeometry(20, 20, 256, 256);
            } else if (config.mode === 'full') {
                // FULL mode - higher resolution for smoother gradients
                geometry = new THREE.PlaneGeometry(10, 10, 200, 200);
            } else if (config.mode === 'mogi') {
                // MOGI mode - Simple sphere for the head
                geometry = new THREE.SphereGeometry(config.mogi.headSize, 64, 64);
            } else {
                // SMOOTH mode
                geometry = new THREE.PlaneGeometry(10, 10, 128, 128);
            }
            
            const color1 = hexToRgb(config.colors[0]);
            const color2 = hexToRgb(config.colors[1]);
            const color3 = hexToRgb(config.colors[2]);
            const color4 = config.colors[3] ? hexToRgb(config.colors[3]) : hexToRgb(config.colors[0]); // Use color1 as fallback instead of black
            
            let material;
            
            if (config.mode === 'mogi') {
                // Simple material for MOGI mode
                const headColor = hexToRgb(config.mogi.headColor);
                material = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(headColor.r, headColor.g, headColor.b),
                    emissive: new THREE.Color(headColor.r * 0.2, headColor.g * 0.2, headColor.b * 0.2),
                    shininess: 100,
                    specular: new THREE.Color(0.2, 0.2, 0.2)
                });
                
                // Add lighting for MOGI mode
                if (!scene.getObjectByName('mogiLight')) {
                    const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
                    light1.position.set(5, 5, 5);
                    light1.name = 'mogiLight';
                    scene.add(light1);
                    
                    const light2 = new THREE.AmbientLight(0x404040);
                    light2.name = 'mogiAmbient';
                    scene.add(light2);
                }
            } else {
                // Remove MOGI lights if they exist
                const mogiLight = scene.getObjectByName('mogiLight');
                if (mogiLight) scene.remove(mogiLight);
                const mogiAmbient = scene.getObjectByName('mogiAmbient');
                if (mogiAmbient) scene.remove(mogiAmbient);
                
                // Regular shader material for other modes
                material = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: {
                    uTime: { value: time },
                    uColor1: { value: new THREE.Vector3(color1.r, color1.g, color1.b) },
                    uColor2: { value: new THREE.Vector3(color2.r, color2.g, color2.b) },
                    uColor3: { value: new THREE.Vector3(color3.r, color3.g, color3.b) },
                    uColor4: { value: new THREE.Vector3(color4.r, color4.g, color4.b) },
                    uHasColor4: { value: config.colors.length >= 4 },
                    uNoiseScale: { value: config.noiseScale },
                    uDistortion: { value: config.distortion },
                    uTimeMultiplier: { value: distortionPresets[config.distortionStyle].timeMultiplier },
                    uAnimationDirection: { value: directionMap[config.animationDirection] },
                    uWaveAmplitude: { value: config.waveAmplitude },
                    uIsNeatMode: { value: config.mode === 'smooth' },
                    uIsFluidMode: { value: config.mode === 'fluid' },
                    uIsFullMode: { value: config.mode === 'full' },
                    uWaveFreqX: { value: config.waveFreqX },
                    uWaveFreqY: { value: config.waveFreqY },
                    uHorizontalPressure: { value: config.horizontalPressure },
                    uVerticalPressure: { value: config.verticalPressure },
                    uWaveDirection: { value: getWaveDirectionValue(config.waveDirection) },
                    uTexture: { value: config.imageTexture },
                    uHasTexture: { value: config.imageTexture !== null },
                    uImageOpacity: { value: config.imageOpacity },
                    uColorBlend: { value: config.colorBlend },
                    uIsTorus: { value: config.shape === 'torus' },
                    uIsLiquidStyle: { value: config.distortionStyle === 'liquid' }
                },
                side: THREE.DoubleSide
            });
            }
            
            mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            
            // Add facial features for MOGI mode
            if (config.mode === 'mogi') {
                // Create a group to hold the facial features
                const mogiGroup = new THREE.Group();
                mogiGroup.name = 'mogiGroup';
                
                // Create left eye
                const leftEyeGeometry = createFeatureGeometry(config.mogi.leftEye.shape, config.mogi.leftEye.size);
                const leftEyeColor = hexToRgb(config.mogi.leftEye.color);
                const leftEyeMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(leftEyeColor.r, leftEyeColor.g, leftEyeColor.b),
                    emissive: new THREE.Color(leftEyeColor.r * 0.1, leftEyeColor.g * 0.1, leftEyeColor.b * 0.1)
                });
                const leftEyeMesh = new THREE.Mesh(leftEyeGeometry, leftEyeMaterial);
                leftEyeMesh.position.set(-config.mogi.headSize * 0.3, config.mogi.headSize * 0.2, config.mogi.headSize * 0.95);
                mogiGroup.add(leftEyeMesh);
                
                // Create right eye
                const rightEyeGeometry = createFeatureGeometry(config.mogi.rightEye.shape, config.mogi.rightEye.size);
                const rightEyeColor = hexToRgb(config.mogi.rightEye.color);
                const rightEyeMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(rightEyeColor.r, rightEyeColor.g, rightEyeColor.b),
                    emissive: new THREE.Color(rightEyeColor.r * 0.1, rightEyeColor.g * 0.1, rightEyeColor.b * 0.1)
                });
                const rightEyeMesh = new THREE.Mesh(rightEyeGeometry, rightEyeMaterial);
                rightEyeMesh.position.set(config.mogi.headSize * 0.3, config.mogi.headSize * 0.2, config.mogi.headSize * 0.95);
                mogiGroup.add(rightEyeMesh);
                
                // Create mouth
                const mouthGeometry = createFeatureGeometry(config.mogi.mouth.shape, config.mogi.mouth.size, true);
                const mouthColor = hexToRgb(config.mogi.mouth.color);
                const mouthMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(mouthColor.r, mouthColor.g, mouthColor.b),
                    emissive: new THREE.Color(mouthColor.r * 0.1, mouthColor.g * 0.1, mouthColor.b * 0.1)
                });
                const mouthMesh = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouthMesh.position.set(0, -config.mogi.headSize * 0.3, config.mogi.headSize * 0.95);
                mogiGroup.add(mouthMesh);
                
                // Add the group to the scene
                scene.add(mogiGroup);
                
                // Store reference to facial features group
                mesh.mogiGroup = mogiGroup;
            }
        }
        
        // Helper function to create geometry for facial features
        function createFeatureGeometry(shape, size, isMouth = false) {
            if (shape === 'circle') {
                return new THREE.SphereGeometry(size, 16, 16);
            } else {
                // Create curved line shapes using TubeGeometry
                const curve = new THREE.CatmullRomCurve3(getFeaturePoints(shape, size, isMouth));
                return new THREE.TubeGeometry(curve, 20, size * 0.1, 8, false);
            }
        }
        
        // Helper function to get points for curved features
        function getFeaturePoints(shape, size, isMouth) {
            const points = [];
            const segments = 10;
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const x = (t - 0.5) * size * 2;
                let y = 0;
                
                if (shape === 'curved-up') {
                    y = Math.sin(t * Math.PI) * size * (isMouth ? 0.3 : 0.5);
                } else if (shape === 'curved-down') {
                    y = -Math.sin(t * Math.PI) * size * (isMouth ? 0.3 : 0.5);
                } else if (shape === 'flat') {
                    y = 0;
                }
                
                points.push(new THREE.Vector3(x, y, 0));
            }
            
            return points;
        }
        
        function switchMode(newMode) {
            config.mode = newMode;
            updateCameraPosition();
            createMesh();
            
            // Update button states
            document.getElementById('mode3d').classList.toggle('active', newMode === '3d');
            document.getElementById('modeFull').classList.toggle('active', newMode === 'full');
            document.getElementById('modeNeat').classList.toggle('active', newMode === 'smooth');
            document.getElementById('modeFluid').classList.toggle('active', newMode === 'fluid');
            document.getElementById('modeMogi').classList.toggle('active', newMode === 'mogi');
            
            // Update cursor and reset rotation
            const canvas = document.getElementById('canvas');
            canvas.style.cursor = newMode === '3d' ? 'grab' : 'default';
            
            // Show/hide mode-specific controls
            const hint = document.getElementById('interactionHint');
            const controls3d = document.getElementById('3dControls');
            const smoothControls = document.getElementById('smoothControls');
            const fluidControls = document.getElementById('fluidControls');
            const mogiControls = document.getElementById('mogiControls');
            const backgroundSection = document.getElementById('backgroundSection');
            
            if (newMode === '3d') {
                autoRotate = true;
                hint.style.opacity = '1';
                hint.classList.add('show');
                controls3d.style.display = 'block';
                backgroundSection.style.display = 'block';
                smoothControls.style.display = 'none';
                fluidControls.style.display = 'none';
                mogiControls.style.display = 'none';
            } else if (newMode === 'smooth') {
                hint.classList.remove('show');
                controls3d.style.display = 'none';
                backgroundSection.style.display = 'none';
                smoothControls.style.display = 'block';
                fluidControls.style.display = 'none';
                mogiControls.style.display = 'none';
            } else if (newMode === 'fluid') {
                hint.classList.remove('show');
                controls3d.style.display = 'none';
                backgroundSection.style.display = 'none';
                smoothControls.style.display = 'none';
                fluidControls.style.display = 'block';
                mogiControls.style.display = 'none';
            } else if (newMode === 'mogi') {
                autoRotate = true;
                hint.classList.remove('show');
                controls3d.style.display = 'none';
                backgroundSection.style.display = 'block';
                smoothControls.style.display = 'none';
                fluidControls.style.display = 'none';
                mogiControls.style.display = 'block';
                // Update cursor for interaction
                const canvas = document.getElementById('canvas');
                canvas.style.cursor = 'grab';
            } else {
                hint.classList.remove('show');
                controls3d.style.display = 'none';
                backgroundSection.style.display = 'none';
                smoothControls.style.display = 'none';
                fluidControls.style.display = 'none';
                mogiControls.style.display = 'none';
            }
            
            // Handle distortion buttons visibility based on mode
            const distortionButtons = document.querySelectorAll('.distortion-btn');
            if (newMode === 'full') {
                // Hide "Smooth" button for FULL mode only
                distortionButtons.forEach(btn => {
                    const style = btn.getAttribute('data-style');
                    if (style === 'smooth') {
                        btn.style.display = 'none';
                    } else {
                        btn.style.display = 'block';
                    }
                });
                
                // If current style is smooth, switch to liquid
                if (config.distortionStyle === 'smooth') {
                    config.distortionStyle = 'liquid';
                    
                    // Update button states
                    distortionButtons.forEach(btn => {
                        btn.classList.remove('active');
                        if (btn.getAttribute('data-style') === 'liquid') {
                            btn.classList.add('active');
                        }
                    });
                    
                    // Apply the liquid preset
                    const preset = distortionPresets['liquid'];
                    config.distortion = preset.distortion;
                    config.noiseScale = preset.noiseScale;
                    config.speed = preset.speed;
                }
            } else if (newMode === '3d' && config.shape === 'torus') {
                // Keep the existing torus logic
                distortionButtons.forEach(btn => {
                    const style = btn.getAttribute('data-style');
                    if (style === 'waves' || style === 'minimal') {
                        btn.style.display = 'none';
                    } else {
                        btn.style.display = 'block';
                    }
                });
            } else {
                // Show all buttons for other modes (3D Sphere, SMOOTH, FLUID)
                distortionButtons.forEach(btn => {
                    btn.style.display = 'block';
                });
            }
        }
        
        function setupModeButtons() {
            document.getElementById('mode3d').addEventListener('click', () => {
                switchMode('3d');
            });
            
            document.getElementById('modeFull').addEventListener('click', () => {
                switchMode('full');
            });
            
            document.getElementById('modeNeat').addEventListener('click', () => {
                switchMode('smooth');
            });
            
            document.getElementById('modeFluid').addEventListener('click', () => {
                switchMode('fluid');
            });
            
            document.getElementById('modeMogi').addEventListener('click', () => {
                switchMode('mogi');
            });
        }
        
        function setupInteraction() {
            const canvas = document.getElementById('canvas');
            
            // Mouse events
            canvas.addEventListener('mousedown', (e) => {
                if (config.mode === '3d' || config.mode === 'mogi') {
                    isDragging = true;
                    autoRotate = false;
                    previousMousePosition = {
                        x: e.clientX,
                        y: e.clientY
                    };
                    // Fade out hint after first interaction
                    const hint = document.getElementById('interactionHint');
                    hint.style.opacity = '0';
                    setTimeout(() => hint.classList.remove('show'), 300);
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging && (config.mode === '3d' || config.mode === 'mogi')) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    targetRotation.y += deltaX * 0.01;
                    targetRotation.x += deltaY * 0.01;
                    
                    previousMousePosition = {
                        x: e.clientX,
                        y: e.clientY
                    };
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
            });
            
            // Touch events for mobile
            canvas.addEventListener('touchstart', (e) => {
                if ((config.mode === '3d' || config.mode === 'mogi') && e.touches.length === 1) {
                    isDragging = true;
                    autoRotate = false;
                    previousMousePosition = {
                        x: e.touches[0].clientX,
                        y: e.touches[0].clientY
                    };
                    // Fade out hint after first interaction
                    const hint = document.getElementById('interactionHint');
                    hint.style.opacity = '0';
                    setTimeout(() => hint.classList.remove('show'), 300);
                    e.preventDefault();
                }
            });
            
            canvas.addEventListener('touchmove', (e) => {
                if (isDragging && (config.mode === '3d' || config.mode === 'mogi') && e.touches.length === 1) {
                    const deltaX = e.touches[0].clientX - previousMousePosition.x;
                    const deltaY = e.touches[0].clientY - previousMousePosition.y;
                    
                    targetRotation.y += deltaX * 0.01;
                    targetRotation.x += deltaY * 0.01;
                    
                    previousMousePosition = {
                        x: e.touches[0].clientX,
                        y: e.touches[0].clientY
                    };
                    e.preventDefault();
                }
            });
            
            canvas.addEventListener('touchend', () => {
                isDragging = false;
            });
            
            // Double-click/tap to reset and resume auto-rotation
            canvas.addEventListener('dblclick', () => {
                if (config.mode === '3d') {
                    autoRotate = true;
                    targetRotation = { x: 0, y: 0 };
                }
            });
            
            // Add cursor pointer when in 3D mode
            canvas.style.cursor = config.mode === '3d' ? 'grab' : 'default';
            
            canvas.addEventListener('mousedown', () => {
                if (config.mode === '3d') canvas.style.cursor = 'grabbing';
            });
            
            canvas.addEventListener('mouseup', () => {
                if (config.mode === '3d') canvas.style.cursor = 'grab';
            });
        }

        function setupControls() {
            console.log('setupControls called');
            console.log('Color circles found:', document.querySelectorAll('.color-circle').length);
            console.log('Popup element exists:', !!document.getElementById('colorPickerPopup'));
            
            // Use event delegation on the parent container for better reliability
            const colorCirclesContainer = document.getElementById('colorCircles');
            if (colorCirclesContainer) {
                colorCirclesContainer.addEventListener('click', function(e) {
                    const colorCircle = e.target.closest('.color-circle');
                    if (colorCircle) {
                        e.stopPropagation();
                        console.log('Color circle clicked via delegation', colorCircle);
                        
                        // Close background popup if open
                        const bgPopup = document.getElementById('bgColorPickerPopup');
                        if (bgPopup) bgPopup.classList.remove('show');
                        
                        const index = parseInt(colorCircle.getAttribute('data-index'));
                        console.log('Color index:', index, 'isNaN:', isNaN(index));
                        if (!isNaN(index) && index !== undefined && index !== null) {
                            currentColorIndex = index;
                            
                            // Get current color and update custom picker
                            const currentColor = config.colors[index];
                            if (typeof mainColorPickerUpdate === 'function') {
                                mainColorPickerUpdate(currentColor);
                            } else {
                                console.error('mainColorPickerUpdate is not a function!');
                            }
                            
                            // Position and show popup
                            const popup = document.getElementById('colorPickerPopup');
                            const colorsSection = document.querySelector('.color-swatches');
                            const controlsPanel = document.querySelector('.controls');
                            console.log('Popup element:', popup);
                            console.log('Colors section:', colorsSection);
                            console.log('Controls panel:', controlsPanel);
                            
                            if (popup) {
                                if (colorsSection && controlsPanel) {
                                    const colorsRect = colorsSection.getBoundingClientRect();
                                    const controlsRect = controlsPanel.getBoundingClientRect();
                                    const maxPopupWidth = Math.min(280, controlsRect.width - 20);
                                    const maxPopupHeight = Math.min(400, controlsRect.height - 20);
                                    
                                    popup.style.maxWidth = maxPopupWidth + 'px';
                                    popup.style.maxHeight = maxPopupHeight + 'px';
                                    
                                    const popupWidth = Math.min(260, maxPopupWidth);
                                    const popupHeight = Math.min(400, maxPopupHeight);
                                    
                                    let leftPos = colorsRect.left + (colorsRect.width / 2) - (popupWidth / 2);
                                    let topPos = colorsRect.top + (colorsRect.height / 2) - (popupHeight / 2);
                                    
                                    if (leftPos < controlsRect.left) leftPos = controlsRect.left + 10;
                                    if (leftPos + popupWidth > controlsRect.right) leftPos = controlsRect.right - popupWidth - 10;
                                    if (topPos < controlsRect.top) topPos = controlsRect.top + 10;
                                    if (topPos + popupHeight > controlsRect.bottom) topPos = controlsRect.bottom - popupHeight - 10;
                                    
                                    popup.style.left = leftPos + 'px';
                                    popup.style.top = topPos + 'px';
                                    popup.style.right = 'auto';
                                    popup.style.transform = 'none';
                                } else {
                                    // Fallback positioning
                                    popup.style.left = '50%';
                                    popup.style.top = '50%';
                                    popup.style.transform = 'translate(-50%, -50%)';
                                }
                                
                                // FORCE SHOW THE POPUP
                                popup.classList.add('show');
                                popup.style.display = 'block';
                                popup.style.visibility = 'visible';
                                popup.style.opacity = '1';
                                console.log('Popup should now be visible!');
                                console.log('Popup display:', window.getComputedStyle(popup).display);
                                console.log('Popup visibility:', window.getComputedStyle(popup).visibility);
                            } else {
                                console.error('Popup element not found!');
                            }
                            
                            // Update active state
                            document.querySelectorAll('.color-circle').forEach(c => c.classList.remove('active'));
                            colorCircle.classList.add('active');
                        }
                    }
                });
            }
            
            // Also keep the direct event listeners as backup
            document.querySelectorAll('.color-circle').forEach(circle => {
                circle.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent event bubbling
                    console.log('Color circle clicked (direct)', this);
                    
                    // Close background popup if open
                    document.getElementById('bgColorPickerPopup').classList.remove('show');
                    
                    const index = parseInt(this.getAttribute('data-index'));
                    console.log('Color index:', index, 'isNaN:', isNaN(index));
                    if (!isNaN(index) && index !== undefined && index !== null) {
                        currentColorIndex = index;
                        
                        // Get current color and update custom picker
                        const currentColor = config.colors[index];
                        mainColorPickerUpdate(currentColor);
                        
                        // Position popup over the colors section (where red box is shown)
                        const popup = document.getElementById('colorPickerPopup');
                        const colorsSection = document.querySelector('.color-swatches');
                        const controlsPanel = document.querySelector('.controls');
                        console.log('Popup element:', popup);
                        console.log('Colors section:', colorsSection);
                        console.log('Controls panel:', controlsPanel);
                        if (popup && colorsSection && controlsPanel) {
                            const colorsRect = colorsSection.getBoundingClientRect();
                            const controlsRect = controlsPanel.getBoundingClientRect();
                            const maxPopupWidth = Math.min(280, controlsRect.width - 20); // Never exceed editor width minus padding
                            const maxPopupHeight = Math.min(400, controlsRect.height - 20); // Never exceed editor height minus padding
                            
                            // Set max dimensions to ensure popup never exceeds editor bounds
                            popup.style.maxWidth = maxPopupWidth + 'px';
                            popup.style.maxHeight = maxPopupHeight + 'px';
                            
                            // Get actual popup dimensions (will be constrained by max-width/max-height)
                            const popupWidth = Math.min(260, maxPopupWidth);
                            const popupHeight = Math.min(400, maxPopupHeight);
                            
                            // Position popup centered over the colors section
                            let leftPos = colorsRect.left + (colorsRect.width / 2) - (popupWidth / 2);
                            let topPos = colorsRect.top + (colorsRect.height / 2) - (popupHeight / 2);
                            
                            // Ensure popup stays completely within editor bounds
                            if (leftPos < controlsRect.left) {
                                leftPos = controlsRect.left + 10;
                            }
                            if (leftPos + popupWidth > controlsRect.right) {
                                leftPos = controlsRect.right - popupWidth - 10;
                            }
                            if (topPos < controlsRect.top) {
                                topPos = controlsRect.top + 10;
                            }
                            if (topPos + popupHeight > controlsRect.bottom) {
                                topPos = controlsRect.bottom - popupHeight - 10;
                            }
                            
                            popup.style.left = leftPos + 'px';
                            popup.style.top = topPos + 'px';
                            popup.style.right = 'auto';
                            popup.style.transform = 'none';
                        } else {
                            console.error('Missing elements:', { popup, colorsSection, controlsPanel });
                            // Fallback: show popup anyway, centered in viewport
                            if (popup) {
                                popup.style.left = '50%';
                                popup.style.top = '50%';
                                popup.style.transform = 'translate(-50%, -50%)';
                            }
                        }
                        
                        // Show popup - ALWAYS show it, even if positioning failed
                        console.log('Showing color picker popup', popup);
                        const popupElement = document.getElementById('colorPickerPopup');
                        if (popupElement) {
                            popupElement.classList.add('show');
                            // Force display in case CSS isn't working
                            popupElement.style.display = 'block';
                            console.log('Popup classes:', popupElement.classList.toString());
                            console.log('Popup computed display:', window.getComputedStyle(popupElement).display);
                            console.log('Popup position:', { left: popupElement.style.left, top: popupElement.style.top });
                        } else {
                            console.error('Popup element not found!');
                        }
                        
                        // Update active state
                        document.querySelectorAll('.color-circle').forEach(c => c.classList.remove('active'));
                        this.classList.add('active');
                    }
                });
            });
            
            // Click outside to close color picker popup
            document.addEventListener('click', (e) => {
                const popup = document.getElementById('colorPickerPopup');
                const isClickInsidePopup = popup.contains(e.target);
                const isColorCircle = e.target.closest('.color-circle');
                
                if (!isClickInsidePopup && !isColorCircle && popup.classList.contains('show')) {
                    popup.classList.remove('show');
                    document.querySelectorAll('.color-circle').forEach(c => c.classList.remove('active'));
                }
            });
            

            // RGB to Hex conversion
            function rgbToHex(r, g, b) {
                const toHex = (n) => {
                    const hex = Math.round(n).toString(16).toUpperCase();
                    return hex.length === 1 ? '0' + hex : hex;
                };
                return '#' + toHex(r) + toHex(g) + toHex(b);
            }
            
            // HSL to RGB conversion
            function hslToRgb(h, s, l) {
                h = h / 360;
                s = s / 100;
                l = l / 100;
                
                let r, g, b;
                
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                return {
                    r: Math.round(r * 255),
                    g: Math.round(g * 255),
                    b: Math.round(b * 255)
                };
            }
            
            // RGB to HSL conversion
            function rgbToHsl(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;
                
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;
                
                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    
                    switch (max) {
                        case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                        case g: h = ((b - r) / d + 2) / 6; break;
                        case b: h = ((r - g) / d + 4) / 6; break;
                    }
                }
                
                return {
                    h: Math.round(h * 360),
                    s: Math.round(s * 100),
                    l: Math.round(l * 100)
                };
            }
            
            // Setup custom color picker for gradient colors
            function setupCustomColorPicker(
                gradientSelector, selectorCircle, hueSlider, hueHandle, huePreview,
                rInput, gInput, bInput, hexInput, 
                isBackground = false
            ) {
                let currentHue = 0;
                let currentSat = 100;
                let currentLight = 50;
                let isDraggingGradient = false;
                let isDraggingHue = false;
                
                // Update gradient background based on hue
                function updateGradientBackground() {
                    const hueColor = `hsl(${currentHue}, 100%, 50%)`;
                    gradientSelector.style.background = `
                        linear-gradient(to bottom, 
                            rgba(255,255,255,1) 0%, 
                            rgba(255,255,255,0) 50%, 
                            rgba(0,0,0,0) 50%, 
                            rgba(0,0,0,1) 100%),
                        linear-gradient(to right, #808080 0%, ${hueColor} 100%)`;
                }
                
                // Update selector circle position
                function updateSelectorPosition() {
                    const x = currentSat;
                    const y = 100 - currentLight;
                    selectorCircle.style.left = x + '%';
                    selectorCircle.style.top = y + '%';
                }
                
                // Update hue handle position
                function updateHueHandlePosition() {
                    const x = (currentHue / 360) * 100;
                    hueHandle.style.left = x + '%';
                }
                
                // Update all inputs from HSL
                function updateFromHSL() {
                    const rgb = hslToRgb(currentHue, currentSat, currentLight);
                    const hexColor = rgbToHex(rgb.r, rgb.g, rgb.b);
                    
                    rInput.value = rgb.r;
                    gInput.value = rgb.g;
                    bInput.value = rgb.b;
                    hexInput.value = hexColor;
                    huePreview.style.backgroundColor = hexColor;
                    
                    // Update the actual color
                    if (isBackground) {
                        updateBackgroundColor(hexColor);
                        document.getElementById('bgColorCircle').style.backgroundColor = hexColor;
                    } else if (currentColorIndex !== null) {
                        config.colors[currentColorIndex] = hexColor;
                        const circle = document.querySelector(`.color-circle[data-index="${currentColorIndex}"]`);
                        if (circle) {
                            circle.style.backgroundColor = hexColor;
                        }
                        const rgb2 = hexToRgb(hexColor);
                        const uniformName = `uColor${currentColorIndex + 1}`;
                        if (mesh && mesh.material.uniforms[uniformName]) {
                            mesh.material.uniforms[uniformName].value.set(rgb2.r, rgb2.g, rgb2.b);
                        }
                    }
                    
                    updateGradientBackground();
                    updateSelectorPosition();
                    updateHueHandlePosition();
                }
                
                // Gradient selector interaction
                gradientSelector.addEventListener('mousedown', (e) => {
                    isDraggingGradient = true;
                    updateGradientSelection(e);
                });
                
                function updateGradientSelection(e) {
                    const rect = gradientSelector.getBoundingClientRect();
                    const x = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
                    const y = Math.max(0, Math.min(100, ((e.clientY - rect.top) / rect.height) * 100));
                    
                    currentSat = x;
                    currentLight = 100 - y;
                    updateFromHSL();
                }
                
                // Hue slider interaction
                hueSlider.addEventListener('mousedown', (e) => {
                    if (e.target === hueSlider || e.target === hueHandle) {
                        isDraggingHue = true;
                        updateHueSelection(e);
                    }
                });
                
                function updateHueSelection(e) {
                    const rect = hueSlider.getBoundingClientRect();
                    const x = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
                    currentHue = (x / 100) * 360;
                    updateFromHSL();
                }
                
                // Global mouse move and up
                document.addEventListener('mousemove', (e) => {
                    if (isDraggingGradient) {
                        updateGradientSelection(e);
                    } else if (isDraggingHue) {
                        updateHueSelection(e);
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    isDraggingGradient = false;
                    isDraggingHue = false;
                });
                
                // RGB input handlers
                [rInput, gInput, bInput].forEach(input => {
                    input.addEventListener('input', () => {
                        const r = parseInt(rInput.value) || 0;
                        const g = parseInt(gInput.value) || 0;
                        const b = parseInt(bInput.value) || 0;
                        
                        const hsl = rgbToHsl(r, g, b);
                        currentHue = hsl.h;
                        currentSat = hsl.s;
                        currentLight = hsl.l;
                        updateFromHSL();
                    });
                });
                
                // Hex input handler
                hexInput.addEventListener('input', (e) => {
                    let value = e.target.value;
                    if (value && !value.startsWith('#')) {
                        value = '#' + value;
                    }
                    
                    if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
                        const rgb = hexToRgb(value);
                        const hsl = rgbToHsl(rgb.r * 255, rgb.g * 255, rgb.b * 255);
                        currentHue = hsl.h;
                        currentSat = hsl.s;
                        currentLight = hsl.l;
                        updateFromHSL();
                    }
                });
                
                // Initialize with current color
                return function(hexColor) {
                    const rgb = hexToRgb(hexColor);
                    const hsl = rgbToHsl(rgb.r * 255, rgb.g * 255, rgb.b * 255);
                    currentHue = hsl.h;
                    currentSat = hsl.s;
                    currentLight = hsl.l;
                    updateFromHSL();
                };
            }
            
            // Initialize custom color pickers
            const mainColorPickerUpdate = setupCustomColorPicker(
                document.getElementById('colorGradientSelector'),
                document.getElementById('colorSelectorCircle'),
                document.getElementById('hueSlider'),
                document.getElementById('hueSliderHandle'),
                document.getElementById('huePreview'),
                document.getElementById('rInput'),
                document.getElementById('gInput'),
                document.getElementById('bInput'),
                document.getElementById('hexInput'),
                false
            );
            
            const bgColorPickerUpdate = setupCustomColorPicker(
                document.getElementById('bgColorGradientSelector'),
                document.getElementById('bgColorSelectorCircle'),
                document.getElementById('bgHueSlider'),
                document.getElementById('bgHueSliderHandle'),
                document.getElementById('bgHuePreview'),
                document.getElementById('bgRInput'),
                document.getElementById('bgGInput'),
                document.getElementById('bgBInput'),
                document.getElementById('bgHexInput'),
                true
            );

            
            // Delete button handlers
            document.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const index = parseInt(this.getAttribute('data-index'));
                    
                    // Don't allow deleting if only 2 colors left
                    if (config.colors.length <= 2) {
                        return;
                    }
                    
                    // Remove color from config
                    config.colors.splice(index, 1);
                    
                    // Rebuild color UI
                    rebuildColorUI();
                    
                    // Recreate mesh with new colors
                    createMesh();
                });
            });
            

            // Add color button
            document.getElementById('addColorBtn').addEventListener('click', () => {
                if (config.colors.length < 4) {
                    const newColor = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
                    config.colors.push(newColor);
                    
                    // Rebuild color UI
                    rebuildColorUI();
                    
                    // Recreate mesh to apply new color
                    createMesh();
                }
            });
            
            // Background color picker handlers
            document.getElementById('bgColorCircle').addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent event bubbling
                
                // Close any other open popups first
                document.getElementById('colorPickerPopup').classList.remove('show');
                
                // Update custom picker with current background color
                bgColorPickerUpdate(config.backgroundColor);
                
                // Position popup over the background color section
                const bgPopup = document.getElementById('bgColorPickerPopup');
                const bgSection = document.querySelector('.background-color-section');
                const controlsPanel = document.querySelector('.controls');
                if (bgPopup && bgSection && controlsPanel) {
                    const bgRect = bgSection.getBoundingClientRect();
                    const controlsRect = controlsPanel.getBoundingClientRect();
                    const maxPopupWidth = Math.min(280, controlsRect.width - 20); // Never exceed editor width minus padding
                    const maxPopupHeight = Math.min(400, controlsRect.height - 20); // Never exceed editor height minus padding
                    
                    // Set max dimensions to ensure popup never exceeds editor bounds
                    bgPopup.style.maxWidth = maxPopupWidth + 'px';
                    bgPopup.style.maxHeight = maxPopupHeight + 'px';
                    
                    // Get actual popup dimensions (will be constrained by max-width/max-height)
                    const popupWidth = Math.min(260, maxPopupWidth);
                    const popupHeight = Math.min(400, maxPopupHeight);
                    
                    // Position popup centered over the background color section
                    let leftPos = bgRect.left + (bgRect.width / 2) - (popupWidth / 2);
                    let topPos = bgRect.top + (bgRect.height / 2) - (popupHeight / 2);
                    
                    // Ensure popup stays completely within editor bounds
                    if (leftPos < controlsRect.left) {
                        leftPos = controlsRect.left + 10;
                    }
                    if (leftPos + popupWidth > controlsRect.right) {
                        leftPos = controlsRect.right - popupWidth - 10;
                    }
                    if (topPos < controlsRect.top) {
                        topPos = controlsRect.top + 10;
                    }
                    if (topPos + popupHeight > controlsRect.bottom) {
                        topPos = controlsRect.bottom - popupHeight - 10;
                    }
                    
                    bgPopup.style.left = leftPos + 'px';
                    bgPopup.style.top = topPos + 'px';
                    bgPopup.style.right = 'auto';
                    bgPopup.style.transform = 'none';
                }
                
                bgPopup.classList.add('show');
            });
            
            // Click outside to close background color picker popup
            document.addEventListener('click', (e) => {
                const bgPopup = document.getElementById('bgColorPickerPopup');
                const isClickInsideBgPopup = bgPopup.contains(e.target);
                const isBgColorCircle = e.target.id === 'bgColorCircle';
                
                if (!isClickInsideBgPopup && !isBgColorCircle && bgPopup.classList.contains('show')) {
                    bgPopup.classList.remove('show');
                }
            });
            

            document.getElementById('speed').addEventListener('input', (e) => {
                config.speed = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = config.speed.toFixed(1);
            });
            
            document.getElementById('waveAmplitude').addEventListener('input', (e) => {
                config.waveAmplitude = parseFloat(e.target.value);
                mesh.material.uniforms.uWaveAmplitude.value = config.waveAmplitude;
                document.getElementById('waveAmplitudeValue').textContent = config.waveAmplitude.toFixed(1);
            });
            
            // FLUID mode controls
            document.getElementById('waveDirection').addEventListener('change', (e) => {
                config.waveDirection = e.target.value;
                mesh.material.uniforms.uWaveDirection.value = getWaveDirectionValue(config.waveDirection);
            });
            
            document.getElementById('waveFreqX').addEventListener('input', (e) => {
                config.waveFreqX = parseFloat(e.target.value);
                mesh.material.uniforms.uWaveFreqX.value = config.waveFreqX;
                document.getElementById('waveFreqXValue').textContent = config.waveFreqX.toFixed(1);
            });
            
            document.getElementById('waveFreqY').addEventListener('input', (e) => {
                config.waveFreqY = parseFloat(e.target.value);
                mesh.material.uniforms.uWaveFreqY.value = config.waveFreqY;
                document.getElementById('waveFreqYValue').textContent = config.waveFreqY.toFixed(1);
            });
            
            document.getElementById('horizontalPressure').addEventListener('input', (e) => {
                config.horizontalPressure = parseFloat(e.target.value);
                mesh.material.uniforms.uHorizontalPressure.value = config.horizontalPressure;
                document.getElementById('horizontalPressureValue').textContent = config.horizontalPressure.toFixed(1);
            });
            
            document.getElementById('verticalPressure').addEventListener('input', (e) => {
                config.verticalPressure = parseFloat(e.target.value);
                mesh.material.uniforms.uVerticalPressure.value = config.verticalPressure;
                document.getElementById('verticalPressureValue').textContent = config.verticalPressure.toFixed(1);
            });
            
            // Color Blend control for 3D mode
            document.getElementById('colorBlend').addEventListener('input', (e) => {
                config.colorBlend = parseFloat(e.target.value);
                mesh.material.uniforms.uColorBlend.value = config.colorBlend;
                document.getElementById('colorBlendValue').textContent = config.colorBlend.toFixed(1);
            });
            
            document.getElementById('size').addEventListener('input', (e) => {
                config.size = parseFloat(e.target.value);
                document.getElementById('sizeValue').textContent = config.size.toFixed(1);
                if (config.mode === '3d') {
                    createMesh(); // Recreate mesh with new size
                }
            });
            
            document.getElementById('noiseScale').addEventListener('input', (e) => {
                config.noiseScale = parseFloat(e.target.value);
                mesh.material.uniforms.uNoiseScale.value = config.noiseScale;
                document.getElementById('noiseScaleValue').textContent = config.noiseScale.toFixed(1);
            });
            
            // Animation direction buttons
            document.querySelectorAll('.direction-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const direction = this.getAttribute('data-direction');
                    config.animationDirection = direction;
                    
                    // Update uniform
                    mesh.material.uniforms.uAnimationDirection.value = directionMap[direction];
                    
                    // Update button states
                    document.querySelectorAll('.direction-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                });
            });
            
            // Distortion style buttons
            document.querySelectorAll('.distortion-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const style = this.getAttribute('data-style');
                    config.distortionStyle = style;
                    
                    // Apply preset based on shape
                    const presets = config.shape === 'torus' ? torusDistortionPresets : distortionPresets;
                    const preset = presets[style];
                    config.distortion = preset.distortion;
                    config.noiseScale = preset.noiseScale;
                    config.speed = preset.speed;
                    
                    // Update mesh uniforms
                    mesh.material.uniforms.uDistortion.value = preset.distortion;
                    mesh.material.uniforms.uNoiseScale.value = preset.noiseScale;
                    mesh.material.uniforms.uTimeMultiplier.value = preset.timeMultiplier;
                    mesh.material.uniforms.uIsLiquidStyle.value = (style === 'liquid');
                    
                    // Update Noise Scale label and range for Torus + Liquid combo
                    const noiseLabel = document.getElementById('noiseScaleLabel');
                    const noiseSlider = document.getElementById('noiseScale');
                    
                    if (config.shape === 'torus' && style === 'liquid') {
                        noiseLabel.textContent = 'Lava Lamp Effect';
                        noiseSlider.min = '0';
                        noiseSlider.max = '3';
                        noiseSlider.step = '0.1';
                        noiseSlider.value = '2';
                        config.noiseScale = 2;
                        mesh.material.uniforms.uNoiseScale.value = 2;
                        document.getElementById('noiseScaleValue').textContent = '2.0';
                    } else {
                        noiseLabel.textContent = 'Noise Scale';
                        noiseSlider.min = '0.5';
                        noiseSlider.max = '5';
                        noiseSlider.step = '0.1';
                        noiseSlider.value = preset.noiseScale;
                        document.getElementById('noiseScaleValue').textContent = preset.noiseScale.toFixed(1);
                    }
                    
                    // Update UI displays
                    document.getElementById('speedValue').textContent = preset.speed.toFixed(1);
                    document.getElementById('speed').value = preset.speed;
                    
                    // Update button states
                    document.querySelectorAll('.distortion-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                });
            });
            
            // Advanced Settings Toggle for FLUID mode
            const advancedToggle = document.getElementById('advancedToggle');
            if (advancedToggle) {
                advancedToggle.addEventListener('click', () => {
                    const advancedSettings = document.getElementById('advancedSettings');
                    if (advancedSettings.style.display === 'none') {
                        advancedSettings.style.display = 'block';
                        advancedToggle.innerHTML = '▼ Advanced Settings';
                        advancedToggle.style.background = 'rgba(255,255,255,0.2)';
                    } else {
                        advancedSettings.style.display = 'none';
                        advancedToggle.innerHTML = '▶ Advanced Settings';
                        advancedToggle.style.background = 'rgba(255,255,255,0.1)';
                    }
                });
            }
            
            // Mood preset buttons
            document.querySelectorAll('.mood-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const mood = this.getAttribute('data-mood');
                    applyMoodPreset(mood);
                    
                    // Visual feedback
                    document.querySelectorAll('.mood-btn').forEach(b => {
                        b.style.boxShadow = 'none';
                        b.style.transform = 'scale(1)';
                    });
                    this.style.boxShadow = '0 0 20px rgba(255, 255, 255, 0.5)';
                    this.style.transform = 'scale(1.05)';
                });
            });
            
            // Shape selection buttons for 3D mode
            document.querySelectorAll('.shape-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const shape = this.getAttribute('data-shape');
                    config.shape = shape;
                    
                    // Update button states
                    document.querySelectorAll('.shape-btn').forEach(b => {
                        b.classList.remove('active');
                        b.style.background = 'rgba(255, 255, 255, 0.1)';
                        b.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                    });
                    this.classList.add('active');
                    this.style.background = 'rgba(255, 255, 255, 0.2)';
                    this.style.borderColor = 'white';
                    
                    // Only handle distortion buttons for 3D mode shapes
                    if (config.mode === '3d') {
                        // Hide/show distortion buttons based on shape
                        const distortionButtons = document.querySelectorAll('.distortion-btn');
                        if (shape === 'torus') {
                            // Hide waves, minimal for Torus
                            distortionButtons.forEach(btn => {
                                const style = btn.getAttribute('data-style');
                                if (style === 'waves' || style === 'minimal') {
                                    btn.style.display = 'none';
                                } else {
                                btn.style.display = 'block';
                            }
                        });
                        
                        // If current style is one that's hidden, switch to smooth
                        if (config.distortionStyle === 'waves' || 
                            config.distortionStyle === 'minimal') {
                            config.distortionStyle = 'smooth';
                            
                            // Update button states
                            distortionButtons.forEach(btn => {
                                btn.classList.remove('active');
                                if (btn.getAttribute('data-style') === 'smooth') {
                                    btn.classList.add('active');
                                }
                            });
                        }
                    } else {
                        // Show all buttons for Sphere
                        distortionButtons.forEach(btn => {
                            btn.style.display = 'block';
                        });
                    }
                    }
                    
                    // Update Noise Scale label and range for Torus + Liquid combo
                    const noiseLabel = document.getElementById('noiseScaleLabel');
                    const noiseSlider = document.getElementById('noiseScale');
                    
                    if (shape === 'torus' && config.distortionStyle === 'liquid') {
                        noiseLabel.textContent = 'Lava Lamp Effect';
                        noiseSlider.min = '0';
                        noiseSlider.max = '3';
                        noiseSlider.step = '0.1';
                        // Keep current value if in reasonable range
                        if (config.noiseScale > 3) {
                            noiseSlider.value = '2';
                            config.noiseScale = 2;
                            mesh.material.uniforms.uNoiseScale.value = 2;
                            document.getElementById('noiseScaleValue').textContent = '2.0';
                        }
                    } else {
                        noiseLabel.textContent = 'Noise Scale';
                        noiseSlider.min = '0.5';
                        noiseSlider.max = '5';
                        noiseSlider.step = '0.1';
                    }
                    
                    // Apply appropriate distortion presets based on shape
                    if (shape === 'torus' && config.distortionStyle) {
                        // Use special presets for torus
                        const torusPresets = {
                            smooth: { distortion: 0.3, noiseScale: 1.5, speed: 1.0, timeMultiplier: 1.0 },
                            liquid: { distortion: 0.0, noiseScale: 2.0, speed: 0.8, timeMultiplier: 0.8 },
                            turbulent: { distortion: 0.5, noiseScale: 3.0, speed: 2.0, timeMultiplier: 2.0 }
                        };
                        const preset = torusPresets[config.distortionStyle];
                        if (preset && mesh) {
                            config.distortion = preset.distortion;
                            config.noiseScale = preset.noiseScale;
                            config.speed = preset.speed;
                            
                            mesh.material.uniforms.uDistortion.value = preset.distortion;
                            mesh.material.uniforms.uNoiseScale.value = preset.noiseScale;
                            mesh.material.uniforms.uTimeMultiplier.value = preset.timeMultiplier;
                            
                            document.getElementById('speedValue').textContent = preset.speed.toFixed(1);
                            document.getElementById('noiseScaleValue').textContent = preset.noiseScale.toFixed(1);
                            document.getElementById('speed').value = preset.speed;
                            document.getElementById('noiseScale').value = preset.noiseScale;
                        }
                    } else if (shape === 'sphere' && config.distortionStyle) {
                        const preset = distortionPresets[config.distortionStyle];
                        if (preset && mesh) {
                            config.distortion = preset.distortion;
                            config.noiseScale = preset.noiseScale;
                            config.speed = preset.speed;
                            
                            mesh.material.uniforms.uDistortion.value = preset.distortion;
                            mesh.material.uniforms.uNoiseScale.value = preset.noiseScale;
                            mesh.material.uniforms.uTimeMultiplier.value = preset.timeMultiplier;
                            
                            document.getElementById('speedValue').textContent = preset.speed.toFixed(1);
                            document.getElementById('noiseScaleValue').textContent = preset.noiseScale.toFixed(1);
                            document.getElementById('speed').value = preset.speed;
                            document.getElementById('noiseScale').value = preset.noiseScale;
                        }
                    }
                    
                    // Recreate mesh with new shape
                    if (config.mode === '3d') {
                        createMesh();
                    }
                });
            });
            
            // MOGI Mode Control Handlers
            setupMogiControls();
        }
        
        // Setup MOGI mode controls
        function setupMogiControls() {
            // Head size control
            const headSizeSlider = document.getElementById('headSize');
            if (headSizeSlider) {
                headSizeSlider.addEventListener('input', function(e) {
                    config.mogi.headSize = parseFloat(e.target.value);
                    document.getElementById('headSizeValue').textContent = config.mogi.headSize.toFixed(1);
                    if (config.mode === 'mogi') {
                        createMesh();
                    }
                });
            }
            
            // Head color picker
            const headColorPreview = document.getElementById('headColorPreview');
            if (headColorPreview) {
                headColorPreview.addEventListener('click', function(e) {
                    const colorPicker = document.createElement('input');
                    colorPicker.type = 'color';
                    colorPicker.value = config.mogi.headColor;
                    colorPicker.addEventListener('change', function() {
                        config.mogi.headColor = colorPicker.value;
                        headColorPreview.style.background = colorPicker.value;
                        if (config.mode === 'mogi') {
                            createMesh();
                        }
                    });
                    colorPicker.click();
                });
            }
            
            // Left eye controls
            const leftEyeShape = document.getElementById('leftEyeShape');
            if (leftEyeShape) {
                leftEyeShape.addEventListener('change', function(e) {
                    config.mogi.leftEye.shape = e.target.value;
                    if (config.mode === 'mogi') createMesh();
                });
            }
            
            const leftEyeSize = document.getElementById('leftEyeSize');
            if (leftEyeSize) {
                leftEyeSize.addEventListener('input', function(e) {
                    config.mogi.leftEye.size = parseFloat(e.target.value);
                    document.getElementById('leftEyeSizeValue').textContent = config.mogi.leftEye.size.toFixed(2);
                    if (config.mode === 'mogi') createMesh();
                });
            }
            
            const leftEyeColorPreview = document.getElementById('leftEyeColorPreview');
            if (leftEyeColorPreview) {
                leftEyeColorPreview.addEventListener('click', function(e) {
                    const colorPicker = document.createElement('input');
                    colorPicker.type = 'color';
                    colorPicker.value = config.mogi.leftEye.color;
                    colorPicker.addEventListener('change', function() {
                        config.mogi.leftEye.color = colorPicker.value;
                        leftEyeColorPreview.style.background = colorPicker.value;
                        if (config.mode === 'mogi') createMesh();
                    });
                    colorPicker.click();
                });
            }
            
            // Right eye controls
            const rightEyeShape = document.getElementById('rightEyeShape');
            if (rightEyeShape) {
                rightEyeShape.addEventListener('change', function(e) {
                    config.mogi.rightEye.shape = e.target.value;
                    if (config.mode === 'mogi') createMesh();
                });
            }
            
            const rightEyeSize = document.getElementById('rightEyeSize');
            if (rightEyeSize) {
                rightEyeSize.addEventListener('input', function(e) {
                    config.mogi.rightEye.size = parseFloat(e.target.value);
                    document.getElementById('rightEyeSizeValue').textContent = config.mogi.rightEye.size.toFixed(2);
                    if (config.mode === 'mogi') createMesh();
                });
            }
            
            const rightEyeColorPreview = document.getElementById('rightEyeColorPreview');
            if (rightEyeColorPreview) {
                rightEyeColorPreview.addEventListener('click', function(e) {
                    const colorPicker = document.createElement('input');
                    colorPicker.type = 'color';
                    colorPicker.value = config.mogi.rightEye.color;
                    colorPicker.addEventListener('change', function() {
                        config.mogi.rightEye.color = colorPicker.value;
                        rightEyeColorPreview.style.background = colorPicker.value;
                        if (config.mode === 'mogi') createMesh();
                    });
                    colorPicker.click();
                });
            }
            
            // Mouth controls
            const mouthShape = document.getElementById('mouthShape');
            if (mouthShape) {
                mouthShape.addEventListener('change', function(e) {
                    config.mogi.mouth.shape = e.target.value;
                    if (config.mode === 'mogi') createMesh();
                });
            }
            
            const mouthSize = document.getElementById('mouthSize');
            if (mouthSize) {
                mouthSize.addEventListener('input', function(e) {
                    config.mogi.mouth.size = parseFloat(e.target.value);
                    document.getElementById('mouthSizeValue').textContent = config.mogi.mouth.size.toFixed(2);
                    if (config.mode === 'mogi') createMesh();
                });
            }
            
            const mouthColorPreview = document.getElementById('mouthColorPreview');
            if (mouthColorPreview) {
                mouthColorPreview.addEventListener('click', function(e) {
                    const colorPicker = document.createElement('input');
                    colorPicker.type = 'color';
                    colorPicker.value = config.mogi.mouth.color;
                    colorPicker.addEventListener('change', function() {
                        config.mogi.mouth.color = colorPicker.value;
                        mouthColorPreview.style.background = colorPicker.value;
                        if (config.mode === 'mogi') createMesh();
                    });
                    colorPicker.click();
                });
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.01 * config.speed;
            
            // Only update shader uniforms if not in MOGI mode
            if (config.mode !== 'mogi' && mesh && mesh.material && mesh.material.uniforms) {
                mesh.material.uniforms.uTime.value = time;
            }
            
            if (config.mode === '3d' || config.mode === 'mogi') {
                if (autoRotate) {
                    // Auto-rotate when not being dragged
                    targetRotation.x += 0.001 * config.speed;
                    targetRotation.y += 0.002 * config.speed;
                }
                
                // Smooth interpolation for rotation
                rotation.x += (targetRotation.x - rotation.x) * 0.1;
                rotation.y += (targetRotation.y - rotation.y) * 0.1;
                
                if (mesh) {
                    mesh.rotation.x = rotation.x;
                    mesh.rotation.y = rotation.y;
                    
                    // Also rotate facial features group in MOGI mode
                    if (config.mode === 'mogi' && mesh.mogiGroup) {
                        mesh.mogiGroup.rotation.x = rotation.x;
                        mesh.mogiGroup.rotation.y = rotation.y;
                    }
                }
            } else {
                // Subtle wave effect in other modes
                if (mesh) {
                    mesh.rotation.z += 0.0005 * config.speed;
                }
            }
            
            renderer.render(scene, camera);
        }

        init();
        
        // Test popup visibility after a short delay
        setTimeout(() => {
            const testPopup = document.getElementById('colorPickerPopup');
            console.log('=== POPUP TEST ===');
            console.log('Popup element:', testPopup);
            if (testPopup) {
                console.log('Popup exists in DOM');
                console.log('Initial display:', window.getComputedStyle(testPopup).display);
                console.log('Initial visibility:', window.getComputedStyle(testPopup).visibility);
                console.log('Initial classes:', testPopup.classList.toString());
                // Temporarily show it to test
                testPopup.style.display = 'block';
                testPopup.style.left = '50%';
                testPopup.style.top = '50%';
                testPopup.style.transform = 'translate(-50%, -50%)';
                testPopup.style.zIndex = '9999';
                console.log('Popup forced visible for 2 seconds...');
                setTimeout(() => {
                    testPopup.style.display = 'none';
                    console.log('Popup hidden again');
                }, 2000);
            } else {
                console.error('POPUP ELEMENT NOT FOUND IN DOM!');
            }
        }, 1000);
        
        // Initialize correct distortion style buttons based on initial shape
        const sphereStyles = document.getElementById('sphereDistortionStyles');
        const torusStyles = document.getElementById('torusDistortionStyles');
        
        if (config.shape === 'torus') {
            sphereStyles.style.display = 'none';
            torusStyles.style.display = 'grid';
        } else {
            sphereStyles.style.display = 'grid';
            torusStyles.style.display = 'none';
        }
    </script>
</body>
</html>